
set removeEventsForLemma = true.

(* Restriction for equivalence *)

restriction
  dom1,dom1',dom2,dom2':domain,idP,idP':idProc;
  event(Selected_lgt(diff[dom1,dom1'],diff[dom2,dom2'],diff[idP,idP'])) ==>
    (* The entries taken from the table should correspond to the requested domains *)
    dom1 = dom2 &&  (* On the left side *)
    dom1' = dom2' && (* On the right side *)
    (
      (* If the requested domains on the left and on the right are the same, we use the same
         idProc to match them. No condition when the requested domains are different *)
      (dom1 = dom1' && idP = idP') || (dom1 <> dom1')
    )
.

restriction
  dom1,dom1',dom2,dom2':domain, idP,idP':idProc;
  event(Selected_psk(diff[dom1,dom1'],diff[dom2,dom2'],diff[idP,idP'])) ==>
    (* The entries taken from the table should correspond to the requested domains *)
    dom1 = dom2 &&
    dom1' = dom2' &&
    (
      (* If the requested domains on the left and on the right are the same, we use the same
         idProc to match them. No condition when the requested domains are different *)
      (dom1 = dom1' && idP = idP') || (dom1 <> dom1')
    )
.

let swap_long_term_keys =
  !
  get long_term_keys(dom1,sk1,pk1,cert1,idP1) in
  get long_term_keys(dom2,sk2,pk2,cert2,idP2) in
  insert long_term_keys(diff[dom1,dom2],diff[sk1,sk2],diff[pk1,pk2],diff[cert1,cert2],diff[idP1,idP2]);
  insert long_term_keys(diff[dom2,dom1],diff[sk2,sk1],diff[pk2,pk1],diff[cert2,cert1],diff[idP2,idP1])
.

let swap_pre_shared_keys =
  !
  get pre_shared_keys(c_dom1,s_dom,h_alg1,id1,psk1,idP1) in
  get pre_shared_keys(c_dom2,=s_dom,h_alg2,id2,psk2,idP2) in
  insert pre_shared_keys(diff[c_dom1,c_dom2],s_dom,diff[h_alg1,h_alg2],diff[id1,id2],diff[psk1,psk2],diff[idP1,idP2]);
  insert pre_shared_keys(diff[c_dom2,c_dom1],s_dom,diff[h_alg1,h_alg2],diff[id2,id1],diff[psk2,psk1],diff[idP2,idP1])
.

(********************************************************)
(* Equivalence scenario                                 *)
(********************************************************)
ifdef(`SCENARIO1',`
  define(`PSK')dnl
  define(`KEX')dnl
  define(`NOGREASE')dnl
  define(`NOCERT')dnl
')dnl
ifdef(`SCENARIO2',`
  define(`KEX')dnl
  define(`NOPSK')dnl
  define(`NOGREASE')dnl
  define(`NOCERT')dnl
')dnl
ifdef(`SCENARIO3',`
  define(`KEX')dnl
  define(`NOPSK')dnl
  define(`NOGREASE')dnl
  define(`CERT')dnl
')dnl
ifdef(`SCENARIO4',`
  define(`KEX')dnl
  define(`UPSK')dnl
  define(`NOGREASE')dnl
  define(`UCERT')dnl
')dnl
ifdef(`SCENARIO5',`
  define(`UKEX')dnl
  define(`UPSK')dnl
  define(`UGREASE')dnl
  define(`UCERT')dnl
')dnl

free ClientA,ClientB,HonestServer:domain.

(* Dishonest key generation *)

let gen_dishonest_long_term_keys =
  !
  in(io,a:domain);
  if a <> HonestServer then
  event Same(d2b(a));
  new sk_d:privkey;
  out(io,(sk_d,valid_cert(a,pk(sk_d))))
.

let gen_dishonest_pre_shared_keys(h_alg:hash_alg) =
  !
  new idP:idProc;
  in(io,(c_dom:domain,s_dom:domain));
  event Same((c_dom,s_dom));
  new psk_d:internal_preSharedKey;
  let id = mk_idpsk(c_dom,s_dom,h_alg,psk_d) in
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk_d,idP);
  out(io,psk_d)
.

(* For privacy of client, we require that certificate of the client-facing-server
   with whom ClientA/ClientB will talk to should not be compromised. Otherwise ProVerif
   found an attack where the attacker plays the role of the server. Note that this
   works also in the PSK scenario as the attacker sends back a server hello
   indicating that the outer client hello was not accepted and so a normal
   TLS connexion follows.

   No requirement on the backend server thought. Their long term keys can be compromised.
*)

process
  (* The group and cipher suite between TLS and Ech should be incompatible *)
  let tls_h = id_hash(StrongHash,1) in
  let tls_a = id_aead(StrongAE,1) in
  let tls_g = id_g(StrongDH,1) in
  let ech_h = id_hash(StrongHash,2) in
  let ech_a = id_aead(StrongAE,2) in
  let ech_g = id_g(StrongDH,2) in
  (
      main_process(tls_h,ech_h,tls_a,ech_a,tls_g,ech_g)
    | swap_pre_shared_keys
    | swap_long_term_keys
    | gen_dishonest_long_term_keys
    | gen_dishonest_pre_shared_keys(tls_h)
    | (
      !
      new id_client:idProc;
      ifdef(`PSK',`let use_psk = true in') ifdef(`NOPSK',`let use_psk = false in') ifdef(`UPSK',`in(io,use_psk:bool);')
      ifdef(`KEX',`let send_kex = true in') ifdef(`NOKEX',`let send_kex = false in') ifdef(`UKEX',`in(io,send_kex:bool);')
      in(io,(c_dom:domain,s_dom:domain));
      event Same((use_psk,send_kex,c_dom,s_dom));
      standard_client(id_client,use_psk,send_kex,c_dom,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      ifdef(`GREASE',`let use_grease = true in') ifdef(`NOGREASE',`let use_grease = false in') ifdef(`UGREASE',`in(io,use_grease:bool);')
      ifdef(`PSK',`let use_psk = true in') ifdef(`NOPSK',`let use_psk = false in') ifdef(`UPSK',`in(io,use_psk:bool);')
      ifdef(`KEX',`let send_kex = true in') ifdef(`NOKEX',`let send_kex = false in') ifdef(`UKEX',`in(io,send_kex:bool);')
      in(io,(c_dom:domain,cfs_dom:domain,backend_dom:domain));
      event Same((use_grease,use_psk,send_kex,c_dom,cfs_dom,backend_dom));
      get ech_configurations(ech_config(id,g,pkR,=cfs_dom,h_alg,a_alg),skR) in
      let ech_conf = ech_config(id,g,pkR,cfs_dom,h_alg,a_alg) in
      echo_client(use_grease,use_psk,send_kex,c_dom,backend_dom,tls_g,tls_h,tls_a,ech_conf,empty_extra_ext,empty_extra_ext)
    ) | (
      !
      ifdef(`PSK',`let use_psk = true in') ifdef(`NOPSK',`let use_psk = false in') ifdef(`UPSK',`in(io,use_psk:bool) [precise];')
      ifdef(`CERT',`let cert_req = true in') ifdef(`NOCERT',`let cert_req = false in') ifdef(`UCERT',`in(io,cert_req:bool) [precise];')
      in(io,(use_ech:bool,s_dom:domain)) [precise];
      event Same((use_ech,use_psk,cert_req,s_dom));
      server(use_ech,use_psk,cert_req,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      ifdef(`GREASE',`let use_grease = true in') ifdef(`NOGREASE',`let use_grease = false in') ifdef(`UGREASE',`in(io,use_grease:bool) [precise];')
      ifdef(`PSK',`let use_psk = true in') ifdef(`NOPSK',`let use_psk = false in') ifdef(`UPSK',`in(io,use_psk:bool) [precise];')
      ifdef(`KEX',`let send_kex = true in') ifdef(`NOKEX',`let send_kex = false in') ifdef(`UKEX',`in(io,send_kex:bool) [precise];')
      in(io,s_dom:domain) [precise];
      event Same((use_grease,use_psk,s_dom));
      get ech_configurations(ech_config(id,g,pkR,=HonestServer,h_alg,a_alg),skR) [precise] in
      let ech_conf = ech_config(id,g,pkR,HonestServer,h_alg,a_alg) in
      echo_client(use_grease,use_psk,send_kex,diff[ClientA,ClientB],s_dom,tls_g,tls_h,tls_a,ech_conf,empty_extra_ext,empty_extra_ext)
    )
  )

ifdef(`SCENARIO1',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 1
END *)
')dnl
')dnl
ifdef(`SCENARIO2',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 2
END *)
')dnl
')dnl
ifdef(`SCENARIO3',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 3
END *)
')dnl
')dnl
ifdef(`SCENARIO4',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 4
END *)
')dnl
')dnl
ifdef(`SCENARIO5',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 5
END *)
')dnl
')dnl
ifdef(`SCENARIO1',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 6
RESULT Diff-equivalence is true.
1377.082s (user 1364.338s + system 12.744s), max rss 5564504K
END *)
')dnl
')dnl
ifdef(`SCENARIO2',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 7
RESULT Diff-equivalence is true.
391.880s (user 390.356s + system 1.524s), max rss 2772016K
END *)
')dnl
')dnl
ifdef(`SCENARIO3',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 8
RESULT Diff-equivalence is true.
869.621s (user 863.861s + system 5.760s), max rss 4201592K
END *)
')dnl
')dnl
ifdef(`SCENARIO4',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 9
RESULT Diff-equivalence is true.
27381.857s (user 27114.798s + system 267.058s), max rss 22477144K
END *)
')dnl
')dnl
ifdef(`SCENARIO5',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client_ech.m4.pv TAG: 10
END *)
')dnl
')dnl
