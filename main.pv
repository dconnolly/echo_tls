(* ProVerif setting *)

set detectNotAttacker = true.
set verboseNotAttacker = true.

(********************************************************)
(* TLS and ECH Setting                                  *)
(********************************************************)

let gen_honest_long_term_keys() =
  !
  in(io,a:domain);
  new sk:privkey;
  event GenCert(a,pk(sk));
  insert long_term_keys(a,sk,pk(sk),valid_cert(a,pk(sk)));
  out(io,pk(sk))
.

let gen_compromised_long_term_keys() =
  !
  in(io,a:domain);
  new sk:privkey;
  insert long_term_keys(a,sk,pk(sk),valid_cert(a,pk(sk)));
  out(io,sk)
.

let gen_honest_pre_shared_keys(h_alg:hash_alg) =
  !
  in(io,(c_dom:domain,s_dom:domain));
  new psk:internal_preSharedKey;
  new id:identityPsk;
  event GenPsk(c_dom,s_dom,PSK(psk));
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk)
.

let gen_compromised_pre_shared_keys(h_alg:hash_alg) =
  !
  in(io,(c_dom:domain,s_dom:domain));
  new psk:internal_preSharedKey;
  new id:identityPsk;
  event GenPsk(c_dom,s_dom,PSK(psk));
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk);
  out(io,psk)
.

letfun make_ech_config(o_dom:domain,g:group,h_alg:hash_alg,a_alg:aead_alg) =
  new id: configId;
  let (skR:bitstring,pkR:element) = dh_keygen(g) in
  let config = ech_config(id,g,pkR,o_dom,h_alg,a_alg) in
  event GenEchConfig(config);
  insert ech_configurations(config,skR);
  config
.

let gen_ech_config(g:group,h_alg:hash_alg,a_alg:aead_alg) =
  !
  in(io,o_dom:domain);
  let config = make_ech_config(o_dom,g,h_alg,a_alg) in
  out(io,config)
.

letfun gen_outdated_ech_config(o_dom:domain,g:group,h_alg:hash_alg,a_alg:aead_alg) =
  new id: configId;
  let (skR:bitstring,pkR:element) = dh_keygen(g) in
  let config = ech_config(id,g,pkR,o_dom,h_alg,a_alg) in
  event GenOutdatedEchConfig(config);
  config
.

(********************************************************)
(* Queries                                              *)
(********************************************************)

(* Sanity checks *)

process
  (* The group and cipher suite between TLS and Ech should be incompatible *)
  let tls_h = id_hash(StrongHash,1) in
  let tls_a = id_aead(StrongAE,1) in
  let tls_g = id_group(StrongDH,1) in
  let ech_h = id_hash(StrongHash,2) in
  let ech_a = id_aead(StrongAE,2) in
  let ech_g = id_group(StrongDH,2) in

  new CFS:domain;
  new BackendA:domain;
  new BackendB:domain;
  out(io,(CFS,BackendA,BackendB));

  let ech_conf = make_ech_config(CFS,ech_g,ech_h,ech_a) in
  out(io,ech_conf);
  (* let ech_conf' = gen_outdated_ech_config(CFS,ech_g,ech_h,ech_a) in
  out(io,ech_conf'); *)

  (
      gen_honest_long_term_keys ()
    | gen_honest_pre_shared_keys (tls_h)
    | (
      !
      in(io,(use_psk:bool,send_kex:bool,c_dom:domain,s_dom:domain));
      standard_client(use_psk,c_dom,s_dom,tls_g,send_kex,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      in(io,(use_psk:bool,send_kex:bool,c_dom:domain));
      echo_client(use_psk,c_dom,BackendA,tls_g,send_kex,tls_h,tls_a,ech_conf,empty_extra_ext,empty_extra_ext)
    (* ) | (
      !
      in(io,(use_psk:bool,send_kex:bool,c_dom:domain));
      echo_client(use_psk,c_dom,BackendA,tls_g,send_kex,tls_h,tls_a,ech_conf',empty_extra_ext,empty_extra_ext) *)
    ) | (
      !
      in(io,(use_ech:bool,use_psk:bool,cert_req:bool,c_dom:domain,s_dom:domain));
      server(use_ech,use_psk,cert_req,c_dom,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    )
  )
