(********************
  Client processes
*********************)

(* Following the TLS RFC and ECHO RFC, we consider client process that can have
  the following parameters:
    - [use_psk] indicate if the client uses Pre Shared Key

  We consider that clients and servers always sends the key_share extension.
  We also consider that server always sends Certificate and CertificateVerify
  messages. We also consider that client always has a public key and a certificate
  but the server does not always asks for it.
  We also consider that the psk_key_exchange_modes is always with (EC)DHE
  hence not modeled here.

  We consider that the client shall support the following:
    - Certificate Request
    - Hello Retry Request
*)

(* Generate the pre shared key extension *)
letfun make_pre_shared_key_extension(
  use_psk:bool,c_dom,s_dom:domain,cr:bytes32, h_alg:hash_alg,a_alg:aead_alg,kex:keyShareExt,ech_ext:echExt,
  extra:extraExt,cur_log:bitstring
  ) =
  if use_psk
  then (
    get pre_shared_keys(=c_dom,=s_dom,=h_alg,id,psk) in
    let offer = nego(TLS13,h_alg,a_alg,kex,SNI(s_dom),ech_ext,trunc_client_psk_ext(id),extra) in
    let cur_log' = (cur_log,CH(cr,offer)) in
    let (es:bitstring,kb:mac_key) = kdf_es(h_alg,psk) in
    let binders = hmac(h_alg,kb,cur_log') in
    (client_psk_ext(id,binders), (h_alg,psk,es))
  )
  else
    let (es:bitstring,kb:mac_key) = kdf_es(h_alg,NoPSK) in
    (empty_psk_ext,(h_alg,NoPSK,es))
.

(* Generate the key share extension. *)
letfun make_key_share_extension(g:group,send_key_share:bool) =
  let (x:bitstring,gx:element) = dh_keygen(g) in
  let kex =
    if send_key_share
    then DHE_kex(g,gx)
    else DHE_group(g)
  in
  (client_kex_ext(kex), (x,g,send_key_share))
.

(* Finished *)

let send_finished_message(id_client:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  psk:preSharedKey,s_pkey,c_pkey:pubkey,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =

  let (cak:aead_key,sak:aead_key,ems:bitstring) = kdf_k(h_alg,master_secret,cur_log) in
  let client_hash_msg = hmac(h_alg,cfin,cur_log) in
  let client_finished_msg = FIN(client_hash_msg) in

  let cur_log' = (cur_log,client_finished_msg) in
  let rms = kdf_psk(h_alg,master_secret,cur_log') in

  insert clientSession(cr,sr,psk,s_pkey,c_pkey,cak,sak,ems,rms);

  let enc_client_finished_msg = aead_enc(a_alg,chk,zero,zero,m2b(client_finished_msg)) in
  out(io,enc_client_finished_msg);
  event SanityClientCFIN(id_client,
    cr,sr,psk,
    master_secret,chk,shk,cfin,sfin,
    s_pkey,c_pkey,
    cak,sak,ems,rms,
    cur_log')
.

(* Certificate and Certificate Verify *)

let send_certificate_message(id_client:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom:domain,s_pkey:pubkey,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =

  get long_term_keys(=c_dom,sk,c_pkey,crt) in

  (* The Certificate message *)
  let certificate_msg = CRT(zero,crt) in
  let encrypted_certificate_msg = aead_enc(a_alg,chk,zero,zero,m2b(certificate_msg)) in
  out(io,encrypted_certificate_msg);

  (* The CertificateVerify message *)
  let cur_log2 = (cur_log,certificate_msg) in
  event SanityClientCCRT(id_client,
    cr,sr,NoPSK,
    master_secret,chk,shk,cfin,sfin,
    s_pkey,c_pkey,
    cur_log2);
  let signed_log = sign(sk,hash(h_alg,cur_log2)) in
  let certificate_verify_msg = CV(signed_log) in
  let encrypted_certificate_verify_msg = aead_enc(a_alg,chk,zero,zero,m2b(certificate_verify_msg)) in
  out(io,encrypted_certificate_verify_msg);
  let cur_log3 = (cur_log2,certificate_verify_msg) in
  event SanityClientCCV(id_client,
    cr,sr,NoPSK,
    master_secret,chk,shk,cfin,sfin,
    s_pkey,c_pkey,
    cur_log3);

  (* The finished message *)
  send_finished_message(id_client,cr,sr,h_alg,a_alg,NoPSK,s_pkey,c_pkey,master_secret,chk,shk,cfin,sfin,cur_log3)
.

(* Receiving Finished message from Server *)

let receive_finished_message(id_client:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom:domain, psk:preSharedKey, cert_req:bool, s_pkey:pubkey,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =

  in(io,enc_finished_msg:bitstring);
  let m2b(finished_msg) = aead_dec(a_alg,shk,zero,zero,enc_finished_msg) in (* QUESTION: What do we do if the decryption fails ? Which error ? *)
    let FIN(hash_msg) = finished_msg in (
      if hash_msg = hmac(h_alg,sfin,cur_log) then
      let cur_log2 = (cur_log,finished_msg) in

      event SanityClientFIN(id_client,
        cr,sr,psk,
        master_secret,chk,shk,cfin,sfin,
        s_pkey,
        cur_log2);

      if cert_req
      then send_certificate_message(id_client,cr,sr,h_alg,a_alg,c_dom,s_pkey,master_secret,chk,shk,cfin,sfin,cur_log2)
      else send_finished_message(id_client,cr,sr,h_alg,a_alg,psk,s_pkey,NoPubKey,master_secret,chk,shk,cfin,sfin,cur_log2)
    )
    else out(io,unexpected_message)
  else out(io,bad_record_mac)
.

(* Process the certificate message and receive the certificate verify *)

let process_server_certificate_message(id_client:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom,s_dom:domain, psk:preSharedKey, cert_req:bool,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring,
  certificate_msg:msg)
  =
  (* Process the Certificate message *)
  let CRT(=zero,crt) = certificate_msg in
  let cur_log2 = (cur_log,certificate_msg) in

  let s_pkey = get_pkey(crt) in (
    event SanityClientCRT(id_client,
      cr,sr,psk,
      master_secret,chk,shk,cfin,sfin,
      s_pkey,
      cur_log2);
    (* Receive the Certificate Verify message *)
    in(io,enc_crt_verif_msg:bitstring);
    let m2b(certificate_verify_msg) = aead_dec(a_alg,shk,zero,zero,enc_crt_verif_msg) in
    let CV(signed_log) = certificate_verify_msg in


    if verify(s_pkey,hash(h_alg,cur_log2),signed_log) && get_domain(crt) = s_dom && verify_cert(crt)
    then (
      let cur_log3 = (cur_log2,certificate_verify_msg) in
      event SanityClientCV(id_client,
        cr,sr,psk,
        master_secret,chk,shk,cfin,sfin,
        s_pkey,
        cur_log3);
      (* Process the Finished message *)
      receive_finished_message(id_client,cr,sr,h_alg,a_alg,c_dom,psk,cert_req,s_pkey,master_secret,chk,shk,cfin,sfin,cur_log3)
    )
    else out(io,abort_error)
  )
  else out(io,decode_error)
.

let receive_server_certificate_message(id_client:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom,s_dom:domain, psk:preSharedKey, cert_req:bool,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =

  in(io,enc_crt_msg:bitstring);
  let m2b(certificate_msg) = aead_dec(a_alg,shk,zero,zero,enc_crt_msg) in
  process_server_certificate_message(id_client,cr,sr,h_alg,a_alg,c_dom,s_dom,psk,cert_req,master_secret,chk,shk,cfin,sfin,cur_log,certificate_msg)
.

(* Receiving message after EncryptedExtensions *)

let receive_after_encrypted_extension (id_client:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom,s_dom:domain, psk:preSharedKey,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =

  if psk = NoPSK
  then (
    (* If no PSK then we expect a certificate from the server *)
    in(io,enc_msg:bitstring);
    let m2b(msg') = aead_dec(a_alg,shk,zero,zero,enc_msg) in

    let CRTR(=zero) = msg' in (
      let cur_log2 = (cur_log,msg') in
      event SanityClientCRTR(id_client,
        cr,sr,psk,
        master_secret,chk,shk,cfin,sfin,
        cur_log2);
      receive_server_certificate_message(id_client,cr,sr,h_alg,a_alg,c_dom,s_dom,psk,true,master_secret,chk,shk,cfin,sfin,cur_log2)
    )
    else let CRT(=zero,crt) = msg' in (
      process_server_certificate_message(id_client,cr,sr,h_alg,a_alg,c_dom,s_dom,psk,false,master_secret,chk,shk,cfin,sfin,cur_log,msg')
    )
    else out(io,unexpected_message)
  )
  else
    (* If there is a PSK, no certificate shall be sent. Directly receive the finish message *)
    receive_finished_message(id_client,
      cr,sr, h_alg,a_alg,
      c_dom, psk, false, NoPubKey,
      master_secret, chk,shk, cfin,sfin,
      cur_log)
.

(* Receiving the encrypted extension message *)

let receive_encrypted_extension_message (id_client:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom,s_dom:domain, psk:preSharedKey,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =
  in(io,enc_ee_msg:bitstring);
  let m2b(ee_msg) = aead_dec(a_alg,shk,zero,zero,enc_ee_msg) in

  let EE(x) = ee_msg in
  (* Should we do something about [x] ? Do we test that it is empty else abort ? *)
  let cur_log2 = (cur_log,ee_msg) in
  event SanityClientEE(id_client,
    cr,sr,psk,
    master_secret,chk,shk,cfin,sfin,
    cur_log2);

  receive_after_encrypted_extension(id_client,cr,sr,h_alg,a_alg,c_dom,s_dom,psk,master_secret,chk,shk,cfin,sfin,cur_log2)
.

(* Generate the keys after the Server Hello *)

let generate_keys_after_server_hello (id_client:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom,s_dom:domain, psk:preSharedKey,
  g:group,x:bitstring,gy:element,early_secret:bitstring,
  cur_log:bitstring)
  =

  (* Compute the handshake secret *)
  let gxy = dh_decap(g,gy,x) in
  let handshake_secret = kdf_hs(h_alg,early_secret,gxy) in
  event SanityClientSH(id_client,cr,sr,c_dom,s_dom,handshake_secret,psk,cur_log);
  let (master_secret:bitstring,chk:aead_key,shk:aead_key,cfin:mac_key,sfin:mac_key) =
    kdf_ms(h_alg,handshake_secret,cur_log)
  in

  receive_encrypted_extension_message(id_client,cr,sr,h_alg,a_alg,c_dom,s_dom,psk,master_secret,chk,shk,cfin,sfin,cur_log)
.

(* Process a server hello message *)

let process_server_hello(id_client:idProc,
  use_psk:bool,
  cr:bytes32,c_dom,s_dom:domain,
  kex_data:bitstring,h_alg:hash_alg,a_alg:aead_alg,psk_data:bitstring,
  cur_log:bitstring,
  server_hello:msg)
  =
  let SH(sr,mode) = server_hello in
  let (x:bitstring,g:group,=true) = kex_data in
  let nego(=TLS13,=h_alg,=a_alg,server_kex_ext(DHE_kex(=g,gy)),=empty_sni_ext,=empty_ech_ext,psk_ext,extra) = mode in (
    let cur_log2 = (cur_log,server_hello) in

    (* We retrieve the pre shared key if there is one. *)
    let (psk:preSharedKey,early_secret:bitstring,valid:bool) =
      if psk_ext = empty_psk_ext
      then (
        let (es:bitstring,kb:mac_key) = kdf_es(h_alg,NoPSK) in
        (NoPSK,es,true)
      )
      else
        let (h'_alg:hash_alg,psk:preSharedKey,es:bitstring) = psk_data in
        (psk,es,((h'_alg = h_alg) && (server_psk_ext(1) = psk_ext) && use_psk))
    in

    if valid
    then generate_keys_after_server_hello(id_client,cr,sr,h_alg,a_alg,c_dom,s_dom,psk,g,x,gy,early_secret,cur_log2)
    else out(io,illegal_parameter)
  )
  else out(io,illegal_parameter)
.

(* Generate the client hello message *)

letfun generate_client_hello_message (
  use_psk:bool,c_dom,s_dom:domain,
  g:group,send_kex:bool,h_alg:hash_alg,a_alg:aead_alg,extra:extraExt, cur_log:bitstring
  )
  =

  let cr = gen_B32_random() in

  (* The key share extension *)
  let (kex_ext:keyShareExt,kex_data:bitstring) = make_key_share_extension(g,send_kex) in

  (* The pre shared key extension *)
  let (psk_ext:preSharedKeyExt,psk_data:bitstring) =
    make_pre_shared_key_extension(use_psk,c_dom,s_dom,cr,h_alg,a_alg,kex_ext,empty_ech_ext,extra,cur_log)
  in

  (* The client hello *)
  let offer = nego(TLS13,h_alg,a_alg,kex_ext,SNI(s_dom),empty_ech_ext,psk_ext,extra) in
  (CH(cr,offer),cr,kex_ext,kex_data,psk_data).

(* The main standard client *)

let standard_client(use_psk:bool,c_dom,s_dom:domain,g:group,send_kex:bool,h_alg:hash_alg,a_alg:aead_alg,extra:extraExt) =
  (****************************************************)
  (* Only for sanity checks *)
  new id_client:idProc;
  event SanityClient(id_client,false,use_psk,send_kex);
  (****************************************************)

  let cur_log = zero in

  let (client_hello:msg,cr:bytes32,kex_ext:keyShareExt,kex_data:bitstring,psk_data:bitstring) = generate_client_hello_message(use_psk,c_dom,s_dom,g,send_kex,h_alg,a_alg,extra,cur_log) in
  out(io,client_hello);
  let cur_log2 = (cur_log,client_hello) in

  (* For sanity checks*)
  let (=h_alg,psk:preSharedKey,es:bitstring) = psk_data in
  event SanityClientCH(id_client,zero32,cr,c_dom,s_dom,psk,cur_log2);

  (* Message from server *)
  in(io,server_hello:msg);
  let SH(sr,mode) = server_hello in (

    if sr = rand_HelloRetryRequest
    then (
      (* We received a HelloRetryRequest *)
      let (nego(=TLS13,=h_alg,=a_alg,hrr_kex_ext(=g),=empty_sni_ext,=empty_ech_ext,=empty_psk_ext,srv_extra),=false) = (mode,send_kex) in (
        let cur_log3 = (cur_log2,server_hello) in
        event SanityClientHRR(id_client,cr,c_dom,s_dom,cur_log3);

        let (client_hello':msg,cr':bytes32,kex_ext':keyShareExt,kex_data':bitstring,psk_data':bitstring) = generate_client_hello_message(use_psk,c_dom,s_dom,g,true,h_alg,a_alg,extra,cur_log3) in
        out(io,client_hello');
        let cur_log4 = (cur_log3,client_hello') in

        (* For sanity checks*)
        let (=h_alg,psk':preSharedKey,es':bitstring) = psk_data' in
        event SanityClientCH(id_client,cr,cr',c_dom,s_dom,psk',cur_log4);

        (* Message from server *)
        in(io,server_hello':msg);
        let SH(sr',mode') = server_hello' in
          if sr' = rand_HelloRetryRequest
          then out(io,unexpected_message)
          else process_server_hello(id_client,use_psk,cr',c_dom,s_dom,kex_data',h_alg,a_alg,psk_data',cur_log4,server_hello')
        else out(io,unexpected_message)
      )
      else out(io,illegal_parameter)
    )
    else
      if send_kex
      then
        (* This is a normal server hello message *)
        process_server_hello(id_client,use_psk,cr,c_dom,s_dom,kex_data,h_alg,a_alg,psk_data,cur_log2,server_hello)
      else out(io,illegal_parameter)
  )
  else out(io,unexpected_message)
.
