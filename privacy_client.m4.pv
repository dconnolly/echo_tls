set removeEventsForLemma = true.

(* Restriction for equivalence *)

restriction
  dom1,dom1',dom2,dom2':domain,idP,idP':idProc;
  event(Selected_lgt(diff[dom1,dom1'],diff[dom2,dom2'],diff[idP,idP'])) ==>
    (* The entries taken from the table should correspond to the requested domains *)
    dom1 = dom2 &&  (* On the left side *)
    dom1' = dom2' && (* On the right side *)
    (
      (* If the requested domains on the left and on the right are the same, we use the same
         idProc to match them. No condition when the requested domains are different *)
      (dom1 = dom1' && idP = idP') || (dom1 <> dom1')
    )
.

restriction
  dom1,dom1',dom2,dom2':domain, idP,idP':idProc;
  event(Selected_psk(diff[dom1,dom1'],diff[dom2,dom2'],diff[idP,idP'])) ==>
    (* The entries taken from the table should correspond to the requested domains *)
    dom1 = dom2 &&
    dom1' = dom2' &&
    (
      (* If the requested domains on the left and on the right are the same, we use the same
         idProc to match them. No condition when the requested domains are different *)
      (dom1 = dom1' && idP = idP') || (dom1 <> dom1')
    )
.

let swap_long_term_keys =
  !
  get long_term_keys(dom1,sk1,pk1,cert1,idP1) in
  get long_term_keys(dom2,sk2,pk2,cert2,idP2) in
  insert long_term_keys(diff[dom1,dom2],diff[sk1,sk2],diff[pk1,pk2],diff[cert1,cert2],diff[idP1,idP2]);
  insert long_term_keys(diff[dom2,dom1],diff[sk2,sk1],diff[pk2,pk1],diff[cert2,cert1],diff[idP2,idP1])
.

let swap_pre_shared_keys =
  !
  get pre_shared_keys(c_dom1,s_dom,h_alg1,id1,psk1,idP1) in
  get pre_shared_keys(c_dom2,=s_dom,h_alg2,id2,psk2,idP2) in
  insert pre_shared_keys(diff[c_dom1,c_dom2],s_dom,diff[h_alg1,h_alg2],diff[id1,id2],diff[psk1,psk2],diff[idP1,idP2]);
  insert pre_shared_keys(diff[c_dom2,c_dom1],s_dom,diff[h_alg1,h_alg2],diff[id2,id1],diff[psk2,psk1],diff[idP2,idP1])
.

fun idClientDiff(seed):idProc [private].

(* We restrict our traces where the process on which we look at the privacy of ClientA/ClientB uses psk that
  are one time used and uncompromised *)
restriction
  ipsk,ipsk1,ipsk2:internal_preSharedKey,idP:idProc, s1,s2,s:seed;
  (* One time used property *)
  event(Selected_otu_psk(idClientDiff(s),diff[ipsk,ipsk1])) && event(Selected_otu_psk(idP,diff[ipsk,ipsk2])) ==> idP = idClientDiff(s);
  event(Selected_otu_psk(idClientDiff(s),diff[ipsk1,ipsk])) && event(Selected_otu_psk(idP,diff[ipsk2,ipsk])) ==> idP = idClientDiff(s);
  (* Ucompromised property *)
  event(Selected_otu_psk(idClientDiff(s),diff[ipsk1,ipsk2])) ==> ipsk1 = uc_psk(s1) && ipsk2 = uc_psk(s2)
.

(* Some public free domains *)

free ClientA,ClientB,HonestServer:domain.

let gen_dishonest_long_term_keys =
  !
  in(io,a:domain);
  if a <> HonestServer then
  event Same(d2b(a));
  new sk_d:privkey;
  out(io,(sk_d,valid_cert(a,pk(sk_d))))
.

let gen_dishonest_pre_shared_keys(h_alg:hash_alg) =
  !
  new idP:idProc;
  in(io,(c_dom:domain,s_dom:domain));
  event Same((c_dom,s_dom));
  new psk_d:internal_preSharedKey;
  let id = mk_idpsk(c_dom,s_dom,h_alg,psk_d) in
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk_d,idP);
  out(io,psk_d)
.

ifdef(<!DISECH!>,<!dnl
let gen_dishonest_ech_config(g:group,h_alg:hash_alg,a_alg:aead_alg) =
  !
  in(io,o_dom:domain);
  if o_dom <> HonestServer then
  event Same(d2b(o_dom));
  new id: configId;
  new skR_d:bitstring;
  let pkR_d = dh_pub(g,skR_d) in
  let config = ech_config(id,g,pkR_d,o_dom,h_alg,a_alg) in
  insert ech_configurations(config,skR_d);
  out(io,(config,skR_d))
.
!>)dnl

(* For privacy of client, we require that certificate of the server with whom
   ClientA/ClientB will talk to should not be compromised. Otherwise we
   find an attack where the attacker plays the role of the server
*)

process
  (* The group and cipher suite between TLS and Ech should be incompatible *)
  let tls_h = id_hash(StrongHash,1) in
  let tls_a = id_aead(StrongAE,1) in
  let tls_g = id_g(StrongDH,1) in
  let ech_h = id_hash(StrongHash,2) in
  let ech_a = id_aead(StrongAE,2) in
  let ech_g = id_g(StrongDH,2) in
  (
      main_process(tls_h,ech_h,tls_a,ech_a,tls_g,ech_g)
    | swap_pre_shared_keys
    | swap_long_term_keys
    | gen_dishonest_long_term_keys
    | gen_dishonest_pre_shared_keys(tls_h)
ifdef(<!DISECH!>,<!dnl
    | gen_dishonest_ech_config(ech_g,ech_h,ech_a)
!>)dnl
    | (
      !
      new id_client:idProc;
      ifdef(<!DOPSK!>,<!let use_psk = true in!>) ifdef(<!NOPSK!>,<!let use_psk = false in!>) ifdef(<!UPSK!>,<!in(io,use_psk:bool);!>)
      ifdef(<!KEX!>,<!let send_kex = true in!>) ifdef(<!NOKEX!>,<!let send_kex = false in!>) ifdef(<!UKEX!>,<!in(io,send_kex:bool);!>)
      in(io,(c_dom:domain,s_dom:domain));
      event Same((use_psk,send_kex,c_dom,s_dom));
      standard_client(id_client,use_psk,send_kex,c_dom,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      ifdef(<!GREASE!>,<!let use_grease = true in!>) ifdef(<!NOGREASE!>,<!let use_grease = false in!>) ifdef(<!UGREASE!>,<!in(io,use_grease:bool);!>)
      ifdef(<!DOPSK!>,<!let use_psk = true in!>) ifdef(<!NOPSK!>,<!let use_psk = false in!>) ifdef(<!UPSK!>,<!in(io,use_psk:bool);!>)
      ifdef(<!KEX!>,<!let send_kex = true in!>) ifdef(<!NOKEX!>,<!let send_kex = false in!>) ifdef(<!UKEX!>,<!in(io,send_kex:bool);!>)
      in(io,(c_dom:domain,cfs_dom:domain,backend_dom:domain));
      event Same((use_grease,use_psk,send_kex,c_dom,cfs_dom,backend_dom));
      get ech_configurations(ech_config(id,g,pkR,=cfs_dom,h_alg,a_alg),skR) in
      let ech_conf = ech_config(id,g,pkR,cfs_dom,h_alg,a_alg) in
      echo_client(use_grease,use_psk,send_kex,c_dom,backend_dom,tls_g,tls_h,tls_a,ech_conf,empty_extra_ext,empty_extra_ext)
    ) | (
      !
      ifdef(<!DOPSK!>,<!let use_psk = true in!>) ifdef(<!NOPSK!>,<!let use_psk = false in!>) ifdef(<!UPSK!>,<!in(io,use_psk:bool) [precise];!>)
      ifdef(<!CERT!>,<!let cert_req = true in!>) ifdef(<!NOCERT!>,<!let cert_req = false in!>) ifdef(<!UCERT!>,<!in(io,cert_req:bool) [precise];!>)
      in(io,(use_ech:bool,s_dom:domain)) [precise];
      event Same((use_ech,use_psk,cert_req,s_dom));
      server(use_ech,use_psk,cert_req,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      in(io,(clientA:domain,clientB:domain)) [precise];
      new s:seed;
      ifdef(<!DOPSK!>,<!let use_psk = true in!>) ifdef(<!NOPSK!>,<!let use_psk = false in!>) ifdef(<!UPSK!>,<!in(io,use_psk:bool) [precise];!>)
      ifdef(<!KEX!>,<!let send_kex = true in!>) ifdef(<!NOKEX!>,<!let send_kex = false in!>) ifdef(<!UKEX!>,<!in(io,send_kex:bool) [precise];!>)
      event Same((use_psk,send_kex));
      standard_client(idClientDiff(s),use_psk,send_kex,diff[ClientA,ClientB],HonestServer,tls_g,tls_h,tls_a,empty_extra_ext)
    )
  )

ifdef(<!SCENARIO1!>,<!
ifdef(<!NOHRR!>,<!!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 1
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO2!>,<!
ifdef(<!NOHRR!>,<!!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 2
RESULT Diff-equivalence is true.
8374.486s (user 8305.434s + system 69.051s), max rss 11361036K
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO3!>,<!
ifdef(<!NOHRR!>,<!!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 3
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO4!>,<!
ifdef(<!NOHRR!>,<!!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 4
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO5!>,<!
ifdef(<!NOHRR!>,<!!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 5
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO6!>,<!
ifdef(<!NOHRR!>,<!!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 6
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO1!>,<!
ifdef(<!NOHRR!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 7
RESULT Diff-equivalence is true.
1013.876s (user 1006.575s + system 7.301s), max rss 4923704K
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO2!>,<!
ifdef(<!NOHRR!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 8
RESULT Diff-equivalence is true.
187.263s (user 185.607s + system 1.656s), max rss 1613856K
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO3!>,<!
ifdef(<!NOHRR!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 9
RESULT Diff-equivalence is true.
414.997s (user 412.449s + system 2.549s), max rss 2817428K
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO4!>,<!
ifdef(<!NOHRR!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 10
RESULT Diff-equivalence is true.
10956.341s (user 10905.061s + system 51.280s), max rss 15005904K
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO5!>,<!
ifdef(<!NOHRR!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 11
END *)
!>)dnl
!>)dnl
ifdef(<!SCENARIO6!>,<!
ifdef(<!NOHRR!>,<!
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 12
END *)
!>)dnl
!>)dnl
