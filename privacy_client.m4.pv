
set removeEventsForLemma = true.

(* Restriction for equivalence *)

restriction dom1,dom1',dom2,dom2':domain,sk,sk':privkey,spkey,spkey':pubkey,crt,crt':certificate;
  event(Selected_lgt(diff[dom1,dom1'],diff[dom2,dom2'],diff[sk,sk'],diff[spkey,spkey'],diff[crt,crt'])) ==>
  dom1 = dom2 && dom1' = dom2' &&
  (
    (dom1 = dom1' && sk = sk' && spkey = spkey' && crt = crt') ||
    (dom1 <> dom1')
  )
.

(* For privacy of client, the server is always the same on the left and on the right *)
restriction idP:idProc,c_dom1,c_dom1',c_dom2,c_dom2',s_dom1,s_dom1',s_dom2,s_dom2':domain,id,id':identityPsk,ipsk,ipsk':internal_preSharedKey;
  event(Selected_psk(idP,diff[c_dom1,c_dom1'],diff[c_dom2,c_dom2'],diff[s_dom1,s_dom1'],diff[s_dom2,s_dom2'],diff[id,id'],diff[ipsk,ipsk'])) ==>
    s_dom1 = s_dom2 && s_dom1' = s_dom2' &&
    c_dom1 = c_dom2 && c_dom1' = c_dom2' &&
    s_dom1 = s_dom1' &&
    (
      (c_dom1 = c_dom1' && id = id' && ipsk = ipsk') || (c_dom1 <> c_dom1')
    )
.

free idClientDiff:idProc [private].

(* We restrict our traces where the process on which we look at the privacy of ClientA/ClientB uses psk that
  are one time used and uncompromised *)
restriction
  idP1,idP2:idProc,s,s':seed,
  c_dom1,c_dom1',c_dom2,c_dom2',c_dom3,c_dom3',c_dom4,c_dom4',s_dom1,s_dom1',s_dom2,s_dom2',s_dom3,s_dom3',s_dom4,s_dom4':domain,
  id1,id1',id2,id2':identityPsk,ipsk1,ipsk1',ipsk2,ipsk2',ipsk:internal_preSharedKey;
  event(Selected_psk(idClientDiff,diff[c_dom1,c_dom1'],diff[c_dom2,c_dom2'],diff[s_dom1,s_dom1'],diff[s_dom2,s_dom2'],diff[id1,id1'],diff[ipsk,ipsk1'])) &&
  event(Selected_psk(idP2,diff[c_dom3,c_dom3'],diff[c_dom4,c_dom4'],diff[s_dom3,s_dom3'],diff[s_dom4,s_dom4'],diff[id2,id2'],diff[ipsk,ipsk2'])) ==>
    idP2 = idClientDiff;
  event(Selected_psk(idClientDiff,diff[c_dom1,c_dom1'],diff[c_dom2,c_dom2'],diff[s_dom1,s_dom1'],diff[s_dom2,s_dom2'],diff[id1,id1'],diff[ipsk1,ipsk])) &&
  event(Selected_psk(idP2,diff[c_dom3,c_dom3'],diff[c_dom4,c_dom4'],diff[s_dom3,s_dom3'],diff[s_dom4,s_dom4'],diff[id2,id2'],diff[ipsk2,ipsk])) ==>
    idP2 = idClientDiff;
  event(Selected_psk(idClientDiff,diff[c_dom1,c_dom1'],diff[c_dom2,c_dom2'],diff[s_dom1,s_dom1'],diff[s_dom2,s_dom2'],diff[id1,id1'],diff[ipsk1,ipsk1'])) ==>
    ipsk1 = uc_psk(s) && ipsk1' = uc_psk(s').

(********************************************************)
(* Equivalence scenario                                 *)
(********************************************************)
ifdef(`SCENARIO1',`
  define(`PSK')dnl
  define(`KEX')dnl
  define(`NOGREASE')dnl
  define(`NOCERT')dnl
')dnl
ifdef(`SCENARIO2',`
  define(`KEX')dnl
  define(`NOPSK')dnl
  define(`NOGREASE')dnl
  define(`NOCERT')dnl
')dnl
ifdef(`SCENARIO3',`
  define(`KEX')dnl
  define(`NOPSK')dnl
  define(`NOGREASE')dnl
  define(`CERT')dnl
')dnl
ifdef(`SCENARIO4',`
  define(`KEX')dnl
  define(`UPSK')dnl
  define(`NOGREASE')dnl
  define(`UCERT')dnl
')dnl
ifdef(`SCENARIO5',`
  define(`UKEX')dnl
  define(`UPSK')dnl
  define(`UGREASE')dnl
  define(`UCERT')dnl
')dnl

free ClientA,ClientB,HonestServer:domain.

let gen_dishonest_long_term_keys =
  !
  in(io,a:domain);
  if a <> HonestServer then
  event Same(d2b(a));
  new sk_d:privkey;
  out(io,(sk_d,valid_cert(a,pk(sk_d))))
.

let gen_dishonest_pre_shared_keys(h_alg:hash_alg) =
  !
  in(io,(c_dom:domain,s_dom:domain));
  event Same((c_dom,s_dom));
  new psk_d:internal_preSharedKey;
  let id = mk_idpsk(c_dom,s_dom,h_alg,psk_d) in
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk_d);
  out(io,psk_d)
.

(* For privacy of client, we require that certificate of the server with whom
   ClientA/ClientB will talk to should not be compromised. Otherwise ProVerif
   found an attack where the attacker plays the role of the server
*)

process
  (* The group and cipher suite between TLS and Ech should be incompatible *)
  let tls_h = id_hash(StrongHash,1) in
  let tls_a = id_aead(StrongAE,1) in
  let tls_g = id_g(StrongDH,1) in
  let ech_h = id_hash(StrongHash,2) in
  let ech_a = id_aead(StrongAE,2) in
  let ech_g = id_g(StrongDH,2) in
  (
      main_process(tls_h,ech_h,tls_a,ech_a,tls_g,ech_g)
    | swap_pre_shared_keys
    | swap_long_term_keys
    | gen_dishonest_long_term_keys
    | gen_dishonest_pre_shared_keys(tls_h)
    | (
      !
      new id_client:idProc;
      ifdef(`PSK',`let use_psk = true in') ifdef(`NOPSK',`let use_psk = false in') ifdef(`UPSK',`in(io,use_psk:bool);')
      ifdef(`KEX',`let send_kex = true in') ifdef(`NOKEX',`let send_kex = false in') ifdef(`UKEX',`in(io,send_kex:bool);')
      in(io,(c_dom:domain,s_dom:domain));
      event Same((use_psk,send_kex,c_dom,s_dom));
      standard_client(id_client,use_psk,send_kex,c_dom,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      ifdef(`GREASE',`let use_grease = true in') ifdef(`NOGREASE',`let use_grease = false in') ifdef(`UGREASE',`in(io,use_grease:bool);')
      ifdef(`PSK',`let use_psk = true in') ifdef(`NOPSK',`let use_psk = false in') ifdef(`UPSK',`in(io,use_psk:bool);')
      ifdef(`KEX',`let send_kex = true in') ifdef(`NOKEX',`let send_kex = false in') ifdef(`UKEX',`in(io,send_kex:bool);')
      in(io,(c_dom:domain,cfs_dom:domain,backend_dom:domain));
      event Same((use_grease,use_psk,send_kex,c_dom,cfs_dom,backend_dom));
      get ech_configurations(ech_config(id,g,pkR,=cfs_dom,h_alg,a_alg),skR) in
      let ech_conf = ech_config(id,g,pkR,cfs_dom,h_alg,a_alg) in
      echo_client(use_grease,use_psk,send_kex,c_dom,backend_dom,tls_g,tls_h,tls_a,ech_conf,empty_extra_ext,empty_extra_ext)
    ) | (
      !
      ifdef(`PSK',`let use_psk = true in') ifdef(`NOPSK',`let use_psk = false in') ifdef(`UPSK',`in(io,use_psk:bool) [precise];')
      ifdef(`CERT',`let cert_req = true in') ifdef(`NOCERT',`let cert_req = false in') ifdef(`UCERT',`in(io,cert_req:bool) [precise];')
      in(io,(use_ech:bool,s_dom:domain)) [precise];
      event Same((use_ech,use_psk,cert_req,s_dom));
      server(use_ech,use_psk,cert_req,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      ifdef(`PSK',`let use_psk = true in') ifdef(`NOPSK',`let use_psk = false in') ifdef(`UPSK',`in(io,use_psk:bool) [precise];')
      ifdef(`KEX',`let send_kex = true in') ifdef(`NOKEX',`let send_kex = false in') ifdef(`UKEX',`in(io,send_kex:bool) [precise];')
      event Same((use_psk,send_kex));
      standard_client(idClientDiff,use_psk,send_kex,diff[ClientA,ClientB],HonestServer,tls_g,tls_h,tls_a,empty_extra_ext)
    )
  )

ifdef(`SCENARIO1',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 1
END *)
')dnl
')dnl
ifdef(`SCENARIO2',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 2
END *)
')dnl
')dnl
ifdef(`SCENARIO3',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 3
END *)
')dnl
')dnl
ifdef(`SCENARIO4',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 4
END *)
')dnl
')dnl
ifdef(`SCENARIO5',`
ifdef(`NOHRR',`',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 5
END *)
')dnl
')dnl
ifdef(`SCENARIO1',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 6
END *)
')dnl
')dnl
ifdef(`SCENARIO2',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 7
END *)
')dnl
')dnl
ifdef(`SCENARIO3',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 8
END *)
')dnl
')dnl
ifdef(`SCENARIO4',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 9
END *)
')dnl
')dnl
ifdef(`SCENARIO5',`
ifdef(`NOHRR',`
(* EXPECTPV FILENAME: ./privacy_client.m4.pv TAG: 10
END *)
')dnl
')dnl
