(* ProVerif setting
  !!! ONLY FOR DEV BRANCH OF PROVERIF
  Leave commented for the master branch
*)

set detectNotAttacker = true.
(* set verboseNotAttacker = true. *)
set removeEventsForLemma = true.

nounif c_dom,s_dom:domain,h:hash_alg,id:identityPsk,x:internal_preSharedKey;
  table(pre_shared_keys( *c_dom, *s_dom, *h, *id, *x)) / -5000
.

nounif c_dom,s_dom:domain,h:hash_alg,id:identityPsk,x:internal_preSharedKey;
  table(pre_shared_keys_diff( *c_dom, *s_dom, *h, *id, *x)) / -4000
.

nounif c_dom:domain,sk_d:privkey,pkr:pubkey,crt:certificate;
  table(long_term_keys( *c_dom, *sk_d, *pkr, *crt)) / -5000
.

nounif config:echConfig,skR:bitstring;
  table(ech_configurations( *config, *skR)) / -5000
.

nounif x:bitstring; mess(ch_client_CFIN,*x) / -3000.
nounif x:bitstring; mess(ch_client_FIN,*x) / -3000.
nounif x:bitstring; mess(ch_client_CRT,*x) / -3000.
nounif x:bitstring; mess(ch_client_after_EE,*x) / -3000.

nounif x:bitstring; mess(ch_server_CFIN,*x) / -3000.
nounif x:bitstring; mess(ch_server_FIN,*x) / -3000.
nounif x:bitstring; mess(ch_server_CRT,*x) / -3000.
nounif x:bitstring; mess(ch_server_SH,*x) / -3000.

(* Restriction for equivalence *)

restriction c_dom1,c_dom1',c_dom2,c_dom2':domain;
  event(Selected_lgt(diff[c_dom1,c_dom1'],diff[c_dom2,c_dom2'])) ==> c_dom1 = c_dom2 && c_dom1' = c_dom2'
.

restriction c_dom1,c_dom1',c_dom2,c_dom2',s_dom1,s_dom1',s_dom2,s_dom2':domain,h_alg1,h_alg1',h_alg2,h_alg2':hash_alg;
  event(Selected_psk(
    diff[c_dom1,c_dom1'],diff[s_dom1,s_dom1'],diff[h_alg1,h_alg1'],
    diff[c_dom2,c_dom2'],diff[s_dom2,s_dom2'],diff[h_alg2,h_alg2'])) ==>
    c_dom1 = c_dom2 && c_dom1' = c_dom2' &&
    s_dom1 = s_dom2 && s_dom1' = s_dom2' &&
    h_alg1 = h_alg2 && h_alg1' = h_alg2'
.

axiom ch:channel,id,id1,id2,id1',id2':idProc,st,st1,st2,st1',st2':bitstring;
  event(PreciseMess(ch,diff[id,id2],diff[st1,st2])) &&
  event(PreciseMess(ch,diff[id,id2'],diff[st1',st2']))
  ==> st1 = st1';
  event(PreciseMess(ch,diff[id1,id],diff[st1,st2])) &&
  event(PreciseMess(ch,diff[id1',id],diff[st1',st2']))
  ==> st2 = st2';
  event(PreciseMess(ch,diff[id1,id2],diff[st,st2])) &&
  event(PreciseMess(ch,diff[id1',id2'],diff[st,st2']))
  ==> id1 = id1';
  event(PreciseMess(ch,diff[id1,id2],diff[st1,st])) &&
  event(PreciseMess(ch,diff[id1',id2'],diff[st1',st]))
  ==> id2 = id2'
.

(********************************************************)
(* TLS and ECH Setting                                  *)
(********************************************************)

let gen_honest_long_term_keys() =
  !
  in(io,a:domain);
  new sk_h:privkey;
  event GenCert(a,pk(sk_h));
  insert long_term_keys(a,sk_h,pk(sk_h),valid_cert(a,pk(sk_h)));
  out(io,pk(sk_h))
.

let gen_compromised_long_term_keys() =
  !
  in(io,a:domain);
  new sk_d:privkey;
  insert long_term_keys(a,sk_d,pk(sk_d),valid_cert(a,pk(sk_d)));
  out(io,sk_d)
.

let gen_honest_pre_shared_keys(h_alg:hash_alg) =
  !
  in(io,(c_dom:domain,s_dom:domain));
  new psk_h:internal_preSharedKey;
  let id = mk_idpsk(c_dom,s_dom,h_alg,psk_h) in
  event GenPsk(c_dom,s_dom,PSK(psk_h));
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk_h)
.

let gen_compromised_pre_shared_keys(h_alg:hash_alg) =
  !
  in(io,(c_dom:domain,s_dom:domain));
  new psk_d:internal_preSharedKey;
  let id = mk_idpsk(c_dom,s_dom,h_alg,psk_d) in
  event GenPsk(c_dom,s_dom,PSK(psk_d));
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk_d);
  out(io,(id,psk_d))
.

letfun make_ech_config(o_dom:domain,g:group,h_alg:hash_alg,a_alg:aead_alg) =
  new id: configId;
  let (skR:bitstring,pkR:element) = dh_keygen(g) in
  let config = ech_config(id,g,pkR,o_dom,h_alg,a_alg) in
  event GenEchConfig(config);
  insert ech_configurations(config,skR);
  config
.

let gen_ech_config(g:group,h_alg:hash_alg,a_alg:aead_alg) =
  !
  in(io,o_dom:domain);
  let config = make_ech_config(o_dom,g,h_alg,a_alg) in
  out(io,config)
.

letfun gen_outdated_ech_config(o_dom:domain,g:group,h_alg:hash_alg,a_alg:aead_alg) =
  new id: configId;
  let (skR:bitstring,pkR:element) = dh_keygen(g) in
  let config = ech_config(id,g,pkR,o_dom,h_alg,a_alg) in
  event GenOutdatedEchConfig(config);
  config
.

let subprocess_client =
    send_finished_message
  | receive_finished_message
  | process_server_certificate_message
  | receive_after_encrypted_extension
.

let subprocess_server =
    receive_client_finished_message
  | send_server_finished_message
  | send_server_certificate_message
  | process_client_hello_noHRR
.

let swap_long_term_keys =
  !
  get long_term_keys(dom1,sk1,pk1,cert1) in
  get long_term_keys(dom2,sk2,pk2,cert2) in
  insert long_term_keys(diff[dom1,dom2],diff[sk1,sk2],diff[pk1,pk2],diff[cert1,cert2]);
  insert long_term_keys(diff[dom2,dom1],diff[sk2,sk1],diff[pk2,pk1],diff[cert2,cert1])
.

let swap_pre_shared_keys =
  !
  get pre_shared_keys(c_dom1,s_dom1,h_alg1,id1,psk1) in
  get pre_shared_keys(c_dom2,s_dom2,h_alg2,id2,psk2) in
  insert pre_shared_keys_diff(diff[c_dom1,c_dom2],diff[s_dom1,s_dom2],diff[h_alg1,h_alg2],diff[id1,id2],diff[psk1,psk2]);
  insert pre_shared_keys_diff(diff[c_dom2,c_dom1],diff[s_dom2,s_dom1],diff[h_alg2,h_alg1],diff[id2,id1],diff[psk2,psk1])
.

(********************************************************)
(* Queries                                              *)
(********************************************************)



process
  (* The group and cipher suite between TLS and Ech should be incompatible *)
  let tls_h = id_hash(StrongHash,1) in
  let tls_a = id_aead(StrongAE,1) in
  let tls_g = id_g(StrongDH,1) in
  let ech_h = id_hash(StrongHash,2) in
  let ech_a = id_aead(StrongAE,2) in
  let ech_g = id_g(StrongDH,2) in

  new CFS:domain;
  new BackendA:domain;
  new BackendB:domain;
  out(io,(CFS,BackendA,BackendB));

  let ech_conf = make_ech_config(CFS,ech_g,ech_h,ech_a) in
  out(io,ech_conf);
  (
      gen_honest_long_term_keys ()
    | gen_honest_pre_shared_keys (tls_h)
    | swap_long_term_keys
    | swap_pre_shared_keys
    | (phase 1; (subprocess_client | subprocess_server))
    | (
      !
      in(io,(use_psk:bool,send_kex:bool,c_dom:domain,s_dom:domain));
      phase 1;
      standard_client(use_psk,send_kex,c_dom,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      in(io,(use_grease:bool,use_psk:bool,send_kex:bool,c_dom:domain));
      phase 1;
      echo_client(use_grease,use_psk,send_kex,c_dom,BackendA,tls_g,tls_h,tls_a,ech_conf,empty_extra_ext,empty_extra_ext)
    ) | (
      !
      in(io,(use_ech:bool,use_psk:bool,cert_req:bool,c_dom:domain,s_dom:domain));
      phase 1;
      server(use_ech,use_psk,cert_req,c_dom,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      in(io,(use_psk:bool,c_dom:domain));
      phase 1;
      echo_client(false,use_psk,true,c_dom,diff[BackendA,BackendB],tls_g,tls_h,tls_a,ech_conf,empty_extra_ext,empty_extra_ext)
    )
  )
