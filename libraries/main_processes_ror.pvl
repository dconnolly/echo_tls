let send_finished_message_ROR =
  !
  in(ch_client_CFIN,(id_client:idProc,
    cr:bytes32,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
    psk:preSharedKey,s_pkey:pubkey,c_pkey:pubkey,
    master_secret:bitstring, chk:aead_key,shk:aead_key, cfin:mac_key,sfin:mac_key,
    cur_log:bitstring)
  );
  new st[]:bitstring;
  event PreciseMess(ch_client_CFIN,id_client,st,cur_log);

  let (cak:aead_key,sak:aead_key,ems:bitstring) = kdf_k(h_alg,master_secret,cur_log) in
  let client_hash_msg = hmac(h_alg,cfin,cur_log) in
  let client_finished_msg = FIN(client_hash_msg) in

  let cur_log' = (cur_log,client_finished_msg) in
  let rms = kdf_psk(h_alg,master_secret,cur_log') in

  (* insert clientSession(a_alg,cr,sr,psk,s_pkey,cak,sak,ems,rms); *)
  let enc_client_finished_msg = aead_enc(a_alg,chk,zero,zero,m2b(client_finished_msg)) in
  out(io,enc_client_finished_msg);
  event SanityClientCFIN(id_client,
    cr,sr,psk,
    master_secret,chk,shk,cfin,sfin,
    s_pkey,c_pkey,
    cak,sak,ems,rms,
    cur_log');

  if s_pkey = NoPubKey || uncompromised_privkey(s_pkey) then
  if psk = NoPSK || uncompromised_psk(psk) then
  new fake_ipsk:internal_preSharedKey;
  out(io,diff[ipsk2b(fake_ipsk),rms])
.

let main_process_ROR(tls_h,ech_h:hash_alg,tls_a,ech_a:aead_alg,tls_g,ech_g:group) =
  (* The clients subprocesses *)
    send_finished_message_ROR
  | receive_finished_message
  | process_server_certificate_message
  | receive_after_encrypted_extension
  (* The server subprocesses *)
  | receive_client_finished_message
  | send_server_finished_message
  | send_server_certificate_message
  | process_client_hello_noHRR
  (* The key generation *)
  | gen_honest_long_term_keys ()
  | gen_honest_pre_shared_keys (tls_h)
  | gen_ech_config(ech_g,ech_h,ech_a)
  (* The application data *)
  (* | application_data *)
.
