(* Secrecy assumption *)

(***** Key Schedule *****)

(*
  - prf(a,k,x): with a = id_hash(StrongHash,i)
      hmac_ideal(i,b2mk(k),x)

  - hkdf_extract(a,s,k) =
      hmac_ideal(i,b2mk(s),k)

  - hkdf_expand_label(a,k,l,h) =
      hmac_ideal(i,b2mk(k),(l,h))

  - derive_secret(a,k,l,m) =
      hmac_ideal(i,b2mk(k),(l,hash_ideal(i,m)))

  - kdf_es(h,PSK(psk)) =
      let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
      let binder_key =
        hmac_ideal(i,b2mk(early_secret),(tls13_resumption_psk_binder_key,hash_ideal(i,zero))) in

  - kdf_es(h,NoPSK) =
      let early_secret = hmac_ideal(i,b2mk(zero),zero) in
      let binder_key =
        hmac_ideal(i,b2mk(early_secret),(tls13_resumption_psk_binder_key,hash_ideal(i,zero))) in

  - kdf_hs(h,early_secret,e) =
      let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero))))
      let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  - kdf_ms(h,handshake_secret,log) =
      let extra_hs = hmac_ideal(i,b2mk(handshake_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
      let master_secret = hmac_ideal(i,b2mk(handshake_secret),zero) in

      let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
      let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in

      let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
      let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in

      let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
      let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
*)

(***** DH keys *****)

(*
  - Honest keys are generated by the function dh_x(s)
  - Encapsulation are generated by the function dh_xy(s)
  - Failed decapsulation are generated by the function dh_f(s)
*)

(* Honest encapsulation will be :
    dh_encap_fun(id_g(StrongDH,i),dh_pub(id_g(StrongDH,i),dh_x(s)),dh_xy(s'))
*)

(* Decapsulation will be either :
    dh_xy(s) (when it is coming from an honest server)
    dh_f(s) (when the decapsultion failed)
    x (when the encapsulation was generated by an attacker)

    Scenario :
      - If Hon server and Hon client then dh_xy stays secret
      - If Hon server and Dis client then dh_xy is known by attacker
      - dh_f is always private as only generate by honest client.
*)

nounif c_dom,c_dom',s_dom,s_dom':domain,h,h':hash_alg,id,id':identityPsk,x,x':internal_preSharedKey;
  table(pre_shared_keys( diff[*c_dom,*c_dom'], diff[*s_dom,*s_dom'], diff[*h,*h'], diff[*id,*id'], diff[*x,*x']))/ -15000
.

nounif c_dom,c_dom':domain,sk_d,sk_d':privkey,pkr,pkr':pubkey,crt,crt':certificate;
  table(long_term_keys( diff[*c_dom,*c_dom'], diff[*sk_d,*sk_d'], diff[*pkr,*pkr'], diff[*crt,*crt'])) / -15000
.

nounif config,config':echConfig,skR,skR':bitstring;
  table(ech_configurations(diff[*config,*config'], diff[*skR,*skR'])) / -15000
.

nounif x,x':bitstring; mess(ch_client_CFIN,diff[*x,*x']) / -13000.
nounif x,x':bitstring; mess(ch_client_FIN,diff[*x,*x']) / -13000.
nounif x,x':bitstring; mess(ch_client_CRT,diff[*x,*x']) / -13000.
nounif x,x':bitstring; mess(ch_client_after_EE,diff[*x,*x']) / -13000.

nounif x,x':bitstring; mess(ch_server_CFIN,diff[*x,*x'])/ -13000.
nounif x,x':bitstring; mess(ch_server_FIN,diff[*x,*x']) / -13000.
nounif x,x':bitstring; mess(ch_server_CRT,diff[*x,*x']) / -13000.
nounif x,x':bitstring; mess(ch_server_SH,diff[*x,*x']) / -13000.

restriction x,x':bitstring; event(Same(diff[x,x'])) ==> x = x'.

axiom ch:channel,id,id1,id2,id1',id2':idProc,st,st1,st2,st1',st2':bitstring, x1,x1',x2,x2':bitstring;
  event(PreciseMess(ch,diff[id,id2],diff[st1,st2],diff[x1,x2])) && event(PreciseMess(ch,diff[id,id2'],diff[st1',st2'],diff[x1',x2'])) ==> st1 = st1' && x1 = x1';
  event(PreciseMess(ch,diff[id1,id],diff[st1,st2],diff[x1,x2])) && event(PreciseMess(ch,diff[id1',id],diff[st1',st2'],diff[x1',x2'])) ==> st2 = st2' && x2 = x2';
  event(PreciseMess(ch,diff[id1,id2],diff[st,st2],diff[x1,x2])) && event(PreciseMess(ch,diff[id1',id2'],diff[st,st2'],diff[x1',x2'])) ==> id1 = id1' && x1 = x1';
  event(PreciseMess(ch,diff[id1,id2],diff[st1,st],diff[x1,x2])) && event(PreciseMess(ch,diff[id1',id2'],diff[st1',st],diff[x1',x2'])) ==> id2 = id2' && x2 = x2'
.

let swap_long_term_keys =
  !
  get long_term_keys(dom1,sk1,pk1,cert1) in
  get long_term_keys(dom2,sk2,pk2,cert2) in
  insert long_term_keys(diff[dom1,dom2],diff[sk1,sk2],diff[pk1,pk2],diff[cert1,cert2]);
  insert long_term_keys(diff[dom2,dom1],diff[sk2,sk1],diff[pk2,pk1],diff[cert2,cert1])
.

let swap_pre_shared_keys =
  !
  get pre_shared_keys(c_dom1,s_dom1,h_alg1,id1,psk1) in
  get pre_shared_keys(c_dom2,s_dom2,h_alg2,id2,psk2) in
  insert pre_shared_keys(diff[c_dom1,c_dom2],diff[s_dom1,s_dom2],diff[h_alg1,h_alg2],diff[id1,id2],diff[psk1,psk2]);
  insert pre_shared_keys(diff[c_dom2,c_dom1],diff[s_dom2,s_dom1],diff[h_alg1,h_alg2],diff[id2,id1],diff[psk2,psk1])
.

(***** Secrecy assumption ****)

not x:privkey,s:seed; attacker(diff[uc_privkey(s),x]).
not x:privkey,s:seed; attacker(diff[x,uc_privkey(s)]).
not x:internal_preSharedKey,s:seed; attacker(diff[uc_psk(s),x]).
not x:internal_preSharedKey,s:seed; attacker(diff[x,uc_psk(s)]).
not x:bitstring, s:seed; attacker(diff[x,dh_k(s)]).
not x:bitstring, s:seed; attacker(diff[dh_k(s),x]).

not attacker(ch_client_CFIN).
not attacker(ch_client_FIN).
not attacker(ch_client_CRT).
not attacker(ch_client_after_EE).

not attacker(ch_server_CFIN).
not attacker(ch_server_FIN).
not attacker(ch_server_CRT).
not attacker(ch_server_SH).

(* Early secret and binder :
    - Secret for non compromised psk
*)

not x:bitstring,i:nat,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  attacker(diff[x,early_secret])
.
not x:bitstring,i:nat,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  attacker(diff[early_secret,x])
.

(* Binder key :
  - Secret for non compromised psk
*)

not x:bitstring,i:nat,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let binder_key = hmac_ideal(i,b2mk(early_secret),(tls13_resumption_psk_binder_key,hash_ideal(i,zero))) in
  attacker(diff[x,binder_key])
.
not x:bitstring,i:nat,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let binder_key = hmac_ideal(i,b2mk(early_secret),(tls13_resumption_psk_binder_key,hash_ideal(i,zero))) in
  attacker(diff[binder_key,x])
.

(* DH Keys *)

not x:element,s:seed; attacker(diff[x,dh_f(s)]).
not x:element,s:seed; attacker(diff[dh_f(s),x]).

not x:element,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  attacker(diff[x,gxy])
.
not x:element,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  attacker(diff[gxy,x])
.

(* Handshake secret :
    - Secret if either the early secret is secret or if the element is secret.

    Other than dh_f, we cannot directly deduce from the handshake secret if the
    element was secret.
*)

not x:bitstring,i:nat,e:element,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in
  attacker(diff[x,handshake_secret])
.
not x:bitstring,i:nat,e:element,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in
  attacker(diff[handshake_secret,x])
.

not x:bitstring,i:nat,e:element,s:seed, extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in
  attacker(diff[x,handshake_secret])
.
not x:bitstring,i:nat,e:element,s:seed, extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in
  attacker(diff[handshake_secret,x])
.

(* Keys wkh and fk
    - Secret if the handshake secret is secret
    - The log is not secret as it is composed only of the client hello messages + server hello +
    possibly the HRR client hello.
*)

(* Case where handshake is secret thanks to psk *)

not x:bitstring,i:nat,e:element,log:bitstring,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
  attacker(diff[x,client_wkh])
.
not x:bitstring,i:nat,e:element,log:bitstring,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
  attacker(diff[client_wkh,x])
.

not x:bitstring,i:nat,e:element,log:bitstring,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
  attacker(diff[x,client_fk])
.
not x:bitstring,i:nat,e:element,log:bitstring,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
  attacker(diff[client_fk,x])
.

not x:bitstring,i:nat,e:element,log:bitstring,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in
  attacker(diff[x,server_wkh])
.
not x:bitstring,i:nat,e:element,log:bitstring,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in
  attacker(diff[server_wkh,x])
.

not x:bitstring,i:nat,e:element,log:bitstring,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
  attacker(diff[x,server_fk])
.
not x:bitstring,i:nat,e:element,log:bitstring,s:seed;
  let psk = uc_psk(s) in
  let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
  attacker(diff[server_fk,x])
.

(* Case where handshake is secret thanks to failure of decapsulation *)

not t:bitstring,i:nat,e:element,s:seed,log:bitstring, x,y,z:bitstring,a:aead_alg,extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
  attacker(diff[t,aead_enc(a,b2ae(client_wkh),x,y,z)])
.
not t:bitstring,i:nat,e:element,s:seed,log:bitstring, x,y,z:bitstring,a:aead_alg,extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
  attacker(diff[aead_enc(a,b2ae(client_wkh),x,y,z),t])
.

not t:bitstring,i:nat,e:element,s:seed,log:bitstring, x,y,z:bitstring,a:aead_alg,extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
  attacker(diff[t,client_fk])
.
not t:bitstring,i:nat,e:element,s:seed,log:bitstring, x,y,z:bitstring,a:aead_alg,extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
  attacker(diff[client_fk,t])
.

not t:bitstring,i:nat,e:element,s:seed,log:bitstring, x,y,z:bitstring,a:aead_alg,extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in
  attacker(diff[t,aead_enc(a,b2ae(server_wkh),x,y,z)])
.
not t:bitstring,i:nat,e:element,s:seed,log:bitstring, x,y,z:bitstring,a:aead_alg,extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in
  attacker(diff[aead_enc(a,b2ae(server_wkh),x,y,z),t])
.

not t:bitstring,i:nat,e:element,s:seed,log:bitstring, x,y,z:bitstring,a:aead_alg,extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
  attacker(diff[t,server_fk])
.
not t:bitstring,i:nat,e:element,s:seed,log:bitstring, x,y,z:bitstring,a:aead_alg,extra_es:bitstring;
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(dh_f(s))) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
  attacker(diff[server_fk,t])
.

(* Client hello coming from an honest client *)
not t:bitstring,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  let gy = dh_encap_fun(g,gx,gxy) in
  let log1 = (log,client_hello) in
  let log2 = (log1,SH(r',nego(v',h',a',server_kex_ext(DHE_kex(g,gy)),sn',e',p',ex'))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(gxy)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log2))) in
  let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
  attacker(diff[t,client_wkh])
.
not t:bitstring,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  let gy = dh_encap_fun(g,gx,gxy) in
  let log1 = (log,client_hello) in
  let log2 = (log1,SH(r',nego(v',h',a',server_kex_ext(DHE_kex(g,gy)),sn',e',p',ex'))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(gxy)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log2))) in
  let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
  attacker(diff[client_wkh,t])
.

not t:bitstring,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,e_key:element,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  let gy = dh_encap_fun(g,gx,gxy) in
  let log1 = (log,client_hello) in
  let log2 = (log1,SH(r',nego(v',h',a',server_kex_ext(DHE_kex(g,gy)),sn',e',p',ex'))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(gxy)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log2))) in
  let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
  attacker(diff[t,client_fk])
.
not t:bitstring,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,e_key:element,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  let gy = dh_encap_fun(g,gx,gxy) in
  let log1 = (log,client_hello) in
  let log2 = (log1,SH(r',nego(v',h',a',server_kex_ext(DHE_kex(g,gy)),sn',e',p',ex'))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(gxy)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log2))) in
  let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
  attacker(diff[client_fk,t])
.

not t:bitstring,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,e_key:element,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  let gy = dh_encap_fun(g,gx,gxy) in
  let log1 = (log,client_hello) in
  let log2 = (log1,SH(r',nego(v',h',a',server_kex_ext(DHE_kex(g,gy)),sn',e',p',ex'))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(gxy)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log2))) in
  let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in
  attacker(diff[t,server_wkh])
.
not t:bitstring,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,e_key:element,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  let gy = dh_encap_fun(g,gx,gxy) in
  let log1 = (log,client_hello) in
  let log2 = (log1,SH(r',nego(v',h',a',server_kex_ext(DHE_kex(g,gy)),sn',e',p',ex'))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(gxy)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log2))) in
  let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in
  attacker(diff[server_wkh,t])
.

not t:bitstring,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,e_key:element,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  let gy = dh_encap_fun(g,gx,gxy) in
  let log1 = (log,client_hello) in
  let log2 = (log1,SH(r',nego(v',h',a',server_kex_ext(DHE_kex(g,gy)),sn',e',p',ex'))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(gxy)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log2))) in
  let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
  attacker(diff[t,server_fk])
.
not t:bitstring,i:nat,s_x, s_xy:seed,r,r':bytes32, v,v':TLS_version, h,h':hash_alg, a,a':aead_alg,
  sn,sn':sniExt, e,e':echExt, p,p':preSharedKeyExt, ex,ex':extraExt, extra_es:bitstring,e_key:element,log:bitstring;
  let g = id_g(StrongDH,i) in
  let gx = dh_pub(g,dh_k(s_x)) in
  let client_hello = CH(r,nego(v,h,a,client_kex_ext(DHE_kex(g,gx)),sn,e,p,ex)) in
  let gxy = dh_xy(s_xy,m2b(client_hello)) in
  let gy = dh_encap_fun(g,gx,gxy) in
  let log1 = (log,client_hello) in
  let log2 = (log1,SH(r',nego(v',h',a',server_kex_ext(DHE_kex(g,gy)),sn',e',p',ex'))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(gxy)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log2))) in
  let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
  attacker(diff[server_fk,t])
.

(* Secrecy assumption related to ECH *)

not x:element,s,s':seed; attacker(diff[x,dh_xy(s',e2b(dh_pub(id_g(StrongDH,2),dh_k(s))))]).
not x:element,s,s':seed; attacker(diff[dh_xy(s',e2b(dh_pub(id_g(StrongDH,2),dh_k(s)))),x]).

not x:bitstring, s,s':seed, info:bitstring, m:hpkeMode;
  let shared_secret = dh_xy(s',e2b(dh_pub(id_g(StrongDH,2),dh_k(s)))) in
  let info_hash = hmac_ideal(2,b2mk(zero),(hpke_info_hash,info)) in
  let xsecret = hmac_ideal(2,b2mk(e2b(shared_secret)),(hpke_secret,zero)) in
  let key = hmac_ideal(2,b2mk(xsecret),(hpke_key,info_hash)) in
  attacker(diff[x,key])
.
not x:bitstring, s,s':seed, info:bitstring, m:hpkeMode;
  let shared_secret = dh_xy(s',e2b(dh_pub(id_g(StrongDH,2),dh_k(s)))) in
  let info_hash = hmac_ideal(2,b2mk(zero),(hpke_info_hash,info)) in
  let xsecret = hmac_ideal(2,b2mk(e2b(shared_secret)),(hpke_secret,zero)) in
  let key = hmac_ideal(2,b2mk(xsecret),(hpke_key,info_hash)) in
  attacker(diff[key,x])
.

not x:bitstring, s,s':seed, info:bitstring, m:hpkeMode;
  let shared_secret = dh_f(s') in
  let info_hash = hmac_ideal(2,b2mk(zero),(hpke_info_hash,info)) in
  let xsecret = hmac_ideal(2,b2mk(e2b(shared_secret)),(hpke_secret,zero)) in
  let key = hmac_ideal(2,b2mk(xsecret),(hpke_key,info_hash)) in
  attacker(diff[x,key])
.
not x:bitstring, s,s':seed, info:bitstring, m:hpkeMode;
  let shared_secret = dh_f(s') in
  let info_hash = hmac_ideal(2,b2mk(zero),(hpke_info_hash,info)) in
  let xsecret = hmac_ideal(2,b2mk(e2b(shared_secret)),(hpke_secret,zero)) in
  let key = hmac_ideal(2,b2mk(xsecret),(hpke_key,info_hash)) in
  attacker(diff[key,x])
.
