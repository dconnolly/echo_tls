(********************************************************)
(* Client ECH                                          *)
(********************************************************)

(* Generate the key share extension for ECH. *)
letfun make_key_share_extension_ech(g:group,send_key_share:bool) =
  let (i_x:bitstring,i_gx:element) = dh_keygen(g) in
  let (o_x:bitstring,o_gx:element) = dh_keygen(g) in

  let (i_kex:kex_alg,o_kex:kex_alg) =
    if send_key_share
    then (DHE_kex(g,i_gx),DHE_kex(g,o_gx))
    else (DHE_group(g),DHE_group(g))
  in

  (client_kex_ext(i_kex),client_kex_ext(o_kex),(i_x,o_x,g,send_key_share))
.

(* Authenticating the ClientHelloOuter. Section 5.1 *)

type ClientHelloOuterAAD.
fun aad2b(ClientHelloOuterAAD):bitstring [typeConverter].
fun client_hello_outer_AAD(hash_alg,aead_alg,configId,element,msg):ClientHelloOuterAAD [data].

letfun generate_client_hello_outer_AAD(client_hello_outer:msg) =
  let CH(r,nego(version,h_alg,a_alg,kex_ext,sni_ext,ech_ext,psk_ext,extra)) = client_hello_outer in
  let client_ECH(h_alg_ech,a_alg_ech,config_id,enc,payload) = ech_ext in

  (* The client_hello_outer with extension removed *)
  let client_hello_outer' = CH(r,nego(version,h_alg,a_alg,kex_ext,sni_ext,empty_ech_ext,psk_ext,extra)) in

  client_hello_outer_AAD(h_alg_ech,a_alg_ech,config_id,enc,client_hello_outer').

(* Receiving the encrypted extension message *)

let receive_encrypted_extension_message_ech (id_client:idProc,
  is_accepted:bool,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom,s_dom:domain, psk:preSharedKey,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =

  in(io,enc_ee_msg:bitstring);
  let m2b(ee_msg) = aead_dec(a_alg,shk,zero,zero,enc_ee_msg) in

  let EE(x) = ee_msg in

  let update_ech_conf =
    if not (is_accepted)
    then
      let echExt2b(server_ECH(ech_conf)) = x in
        (* Case of a ECH Server / Client Facing server *)
        (* QUESTION : What do we do with it ?*)
        ()
      else
        (* Case of a Normal Server *)
        ()
    else ()
  in

  let cur_log2 = (cur_log,ee_msg) in
  out(ch_client_after_EE,(id_client,cr,sr,h_alg,a_alg,c_dom,s_dom,psk,master_secret,chk,shk,cfin,sfin,cur_log2))
.

(* Process a server hello message *)

let process_server_hello_ech(id_client:idProc,
  use_grease,use_psk:bool,
  i_cr,o_cr:bytes32,c_dom,i_dom,o_dom:domain,
  kex_data:bitstring,h_alg:hash_alg,a_alg:aead_alg,psk_data:bitstring,
  i_cur_log,o_cur_log:bitstring,
  server_hello:msg)
  =
  let SH(B32(sr24,sr8),mode) = server_hello in
  let (i_x:bitstring,o_x:bitstring,g:group,=true) = kex_data in
  let nego(=TLS13,=h_alg,=a_alg,server_kex_ext(DHE_kex(=g,gy_srv)),=empty_sni_ext,=empty_ech_ext,psk_ext,extra) = mode in (

    (* We retrieve the pre shared key if there is one. *)
    let (psk:preSharedKey,early_secret:bitstring,valid:bool) =
      if psk_ext = empty_psk_ext
      then (
        let (es:bitstring,kb:mac_key) = kdf_es(h_alg,NoPSK) in
        (NoPSK,es,true)
      )
      else
        let (h'_alg:hash_alg,psk:preSharedKey,es:bitstring) = psk_data in
        (psk,es,(h'_alg = h_alg && server_psk_ext(1) = psk_ext && use_psk))
    in

    if valid
    then (
      (* Determinaing whether ECH was accepted or not *)
      let is_accepted:bool =
        if use_grease
        then false
        else
          (* Compute the handshake secret *)
          let i_gxy = dh_decap(g,gy_srv,i_x) in
          let i_handshake_secret = kdf_hs(h_alg,early_secret,i_gxy) in
          let SH_ECHConf = SH(B32(sr24,zero8),mode) in
          let accept_confirmation = derive_secret(h_alg,i_handshake_secret,ech_accept_confirmation,(i_cur_log,SH_ECHConf)) in
          sr8 = crop_into_bytes8(accept_confirmation)
      in

      let (cr:bytes32,handshake_secret:bitstring,s_dom:domain,cur_log:bitstring) =
        if is_accepted
        then (
          let i_gxy = dh_decap(g,gy_srv,i_x) in
          let i_handshake_secret = kdf_hs(h_alg,early_secret,i_gxy) in
          (i_cr,i_handshake_secret,i_dom,(i_cur_log,server_hello))
        )
        else
          (* Must compute early secret with NoPSK *)
          let o_gxy = dh_decap(g,gy_srv,o_x) in
          let o_early_secret =
            if use_grease
            then early_secret
            else
              let (es:bitstring,kb:mac_key) = kdf_es(h_alg,NoPSK)  in
              es
          in
          (o_cr,kdf_hs(h_alg,o_early_secret,o_gxy), o_dom,(o_cur_log,server_hello))
      in

      let (master_secret:bitstring,chk:aead_key,shk:aead_key,cfin:mac_key,sfin:mac_key) =
        kdf_ms(h_alg,handshake_secret,cur_log)
      in

      event SanityClientSH(id_client,cr,B32(sr24,sr8),c_dom,s_dom,handshake_secret,psk,cur_log);

      receive_encrypted_extension_message_ech(id_client,
        is_accepted,
        cr,B32(sr24,sr8),h_alg,a_alg,
        c_dom,s_dom,psk,
        master_secret,chk,shk,cfin,sfin,
        cur_log
      )
    )
    else out(io,illegal_parameter)
  )
  else out(io,illegal_parameter)
.

(* Generate the client hello message *)

letfun generate_client_hello_message_ech (
  use_grease,use_psk:bool,c_dom,i_dom:domain,
  g:group,send_kex:bool,h_alg:hash_alg,a_alg:aead_alg, (* For main configuration *)
  ech_conf:echConfig,enc:element,context:hpkeContext,n:nat, (* For ech *)
  i_extra,o_extra:extraExt,
  cur_log:bitstring (* When use_grease = true then the current log should be zero or ((zero,outer),HRR)
    When use_grease <> true, then [cur_log] should be zero or [(zero,inner),HRR] *)
  ) =

  let ech_config(config_id,g_ech,pkR,o_dom,h_alg_ech,a_alg_ech) = ech_conf in

  (* The key share extension *)
  let (i_kex_ext:keyShareExt,o_kex_ext:keyShareExt,kex_data:bitstring) = make_key_share_extension_ech(g,send_kex) in

  (* Generate the random for the inner and outer client hello *)
  let i_cr = gen_B32_random () in
  let o_cr = gen_B32_random () in

  (* Generate the ech_extension for the inner when grease <> true and outer when grease = true *)
  let ech_inner_or_grease =
    if use_grease
    then
      new payload[]:bitstring;
      client_ECH(h_alg_ech,a_alg_ech,config_id,enc,payload)
    else ech_is_inner
  in

  (* The pre shared key extension for the inner when grease <> true and outer when grease = true *)
  let (psk_ext:preSharedKeyExt,psk_data:bitstring) =
    let (dom_psk:domain,cr_psk:bytes32,kex_ext_psk:keyShareExt,extra_psk:extraExt) =
      if use_grease
      then (o_dom,o_cr,o_kex_ext,o_extra)
      else (i_dom,i_cr,i_kex_ext,i_extra)
    in
    make_pre_shared_key_extension(use_psk,c_dom,dom_psk,cr_psk,h_alg,a_alg,kex_ext_psk,ech_inner_or_grease,extra_psk,cur_log)
  in

  (* The inner client hello *)
  let i_offer = nego(TLS13,h_alg,a_alg,i_kex_ext,SNI(i_dom),ech_is_inner,psk_ext,i_extra) in
  let i_client_hello = CH(i_cr,i_offer) in

  if use_grease
  then (
    let o_offer = nego(TLS13,h_alg,a_alg,o_kex_ext,SNI(o_dom),ech_inner_or_grease,psk_ext,o_extra) in
    (CH(o_cr,o_offer),CH(o_cr,o_offer),o_cr,o_cr,o_kex_ext,o_kex_ext,kex_data,psk_data)
  )
  else (
    let o_psk_ext =
      if use_psk
      then
        new fake_id[]:identityPsk;
        new fake_binder[]:bitstring;
        client_psk_ext(fake_id,fake_binder)
      else empty_psk_ext
    in

    let dummy_ech_ext = client_ECH(h_alg_ech,a_alg_ech,config_id,enc,zero) in

    let o_offer1 = nego(TLS13,h_alg,a_alg,o_kex_ext,SNI(o_dom),dummy_ech_ext,o_psk_ext,o_extra) in
    let o_client_hello1 = CH(o_cr,o_offer1) in

    let client_hello_AAD = generate_client_hello_outer_AAD(o_client_hello1) in

    let payload = kpke_seal(a_alg_ech,context,n,aad2b(client_hello_AAD),m2b(i_client_hello)) in

    let ech_ext = client_ECH(h_alg_ech,a_alg_ech,config_id,enc,payload) in

    let o_offer = nego(TLS13,h_alg,a_alg,o_kex_ext,SNI(o_dom),ech_ext,o_psk_ext,o_extra) in
    (CH(o_cr,o_offer),i_client_hello,i_cr,o_cr,i_kex_ext,o_kex_ext,kex_data,psk_data)
  )
.

(* The main ECH client *)

let echo_client(use_grease:bool,use_psk:bool,send_kex:bool,c_dom,i_dom:domain,
  g:group,h_alg:hash_alg,a_alg:aead_alg, (* For main configuration *)
  ech_conf:echConfig,
  i_extra,o_extra:extraExt
  ) =
  (****************************************************)
  (* Only for sanity checks *)
  new id_client[]:idProc;
  event SanityClient(id_client,true,use_grease,use_psk,send_kex);
  (****************************************************)

  (* Generating the HPKE Context (Section 6.1 in RFC)*)
  let ech_config(config_id,g_ech,pkR,o_dom,h_alg_ech,a_alg_ech) = ech_conf in
  let (enc:element,context:hpkeContext) = hpke_setup_base_S(h_alg_ech,g_ech,pkR,(tls_ech_str,ech_conf)) in

  let (o_client_hello:msg,i_client_hello:msg,i_cr:bytes32,o_cr:bytes32,i_kex_ext:keyShareExt,o_kex_ext:keyShareExt,kex_data:bitstring,psk_data:bitstring) =
    generate_client_hello_message_ech (
      use_grease,use_psk,c_dom,i_dom,
      g,send_kex,h_alg,a_alg, (* For main configuration *)
      ech_conf,enc,context,1,(* For ech *)
      i_extra,o_extra, zero
      )
  in
  out(io,o_client_hello);

  (* For sanity checks*)
  let (=h_alg,psk:preSharedKey,es:bitstring) = psk_data in
  let o_dom = get_public_name(ech_conf) in
  event SanityClientCH_ECH(id_client,true,i_cr,o_cr,c_dom,o_dom,i_dom,psk,(zero,o_client_hello),(zero,i_client_hello));

  (* Message from server *)
  in(io,server_hello:msg);
  let SH(sr,mode) = server_hello in (

    if sr = rand_HelloRetryRequest
    then
      (* We received a HelloRetryRequest *)
      let (nego(=TLS13,=h_alg,=a_alg,hrr_kex_ext(=g),=empty_sni_ext,=empty_ech_ext,=empty_psk_ext,srv_extra),=false) = (mode,send_kex) in (
        let o_cur_log = ((zero,o_client_hello),server_hello) in
        let i_cur_log = ((zero,i_client_hello),server_hello) in

        let cur_log_for_psk =
          if use_grease
          then o_cur_log
          else i_cur_log
        in
        event SanityClientHRR(id_client);

        let (o_client_hello':msg,i_client_hello':msg,i_cr':bytes32,o_cr':bytes32,i_kex_ext':keyShareExt,o_kex_ext':keyShareExt,kex_data':bitstring,psk_data':bitstring) =
          generate_client_hello_message_ech (
            use_grease,use_psk,c_dom,i_dom,
            g,true,h_alg,a_alg, (* For main configuration *)
            ech_conf,enc,context,2, (* For ech *)
            i_extra,o_extra, cur_log_for_psk
            )
        in
        out(io,o_client_hello');
        let o_cur_log2 = (o_cur_log,o_client_hello') in
        let i_cur_log2 = (i_cur_log,i_client_hello') in

        (* For sanity checks*)
        let (=h_alg,psk':preSharedKey,es':bitstring) = psk_data' in
        event SanityClientCH_ECH(id_client,false,i_cr',o_cr',c_dom,o_dom,i_dom,psk',o_cur_log2,i_cur_log2);

        (* Message from server *)
        in(io,server_hello':msg);
        let SH(sr',mode') = server_hello' in
          if sr' = rand_HelloRetryRequest
          then out(io,unexpected_message)
          else
            (* This is a normal server hello message *)
            process_server_hello_ech(id_client,
              use_grease,use_psk,
              i_cr',o_cr',c_dom,i_dom,o_dom,
              kex_data',h_alg,a_alg,psk_data',
              i_cur_log2,o_cur_log2,
              server_hello'
            )
        else out(io,unexpected_message)
      )
      else out(io,illegal_parameter)
    else
      (* This is a normal server hello message *)
      process_server_hello_ech(id_client,
        use_grease,use_psk,
        i_cr,o_cr,c_dom,i_dom,o_dom,
        kex_data,h_alg,a_alg,psk_data,
        (zero,i_client_hello),(zero,o_client_hello),
        server_hello
      )
  )
  else out(io,unexpected_message)
.
