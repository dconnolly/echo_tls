
set removeEventsForLemma = true.
set verboseLemmas = true.

nounif s_dom:domain, h_alg:hash_alg, psk:preSharedKey; attacker(mk_idpsk( *s_dom, *h_alg, *psk)).

nounif c_dom,s_dom:domain,h:hash_alg,id:identityPsk,x:preSharedKey, idP:idProc,is_safe:bool;
  table(pre_shared_keys( *c_dom, *s_dom, *h, *id, *x, *idP, *is_safe))
.

axiom c_dom,s_dom:domain,h:hash_alg,id:identityPsk,cr,sr:bytes32,old_psk,psk:preSharedKey,idP:idProc,is_safe:bool,i:nat,e:element,s:seed,log:bitstring, s_pkey:pubkey;
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,is_safe)) ==> attacker(id) || id = mk_idpsk(s_dom,h,psk);
  attacker(mk_idpsk(s_dom,h,psk)) && attacker(psk) ==>
    event(ServerNewTicket(old_psk,s_pkey,psk)) || event(CompromisedPsk(psk));
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,true)) && attacker(psk);
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,is_safe)) && attacker(psk) ==> is_safe = false;
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,false)) ==> event(CompromisedPsk(psk));
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,is_safe)) ==> psk <> NoPsk && psk <> b2psk(zero);
  (* ------ *)
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,true)) &&
  let early_secret = hmac_ideal(i,b2mk(zero),psk2b_pf(psk)) in
  attacker(early_secret);
  (* ------ *)
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,true)) &&
  let early_secret = hmac_ideal(i,b2mk(zero),psk2b_pf(psk)) in
  let binder_key = hmac_ideal(i,b2mk(early_secret),(tls13_ext_res_binder,hash_ideal(i,zero))) in
  attacker(binder_key);
  (* ------ *)
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,true)) &&
  let early_secret = hmac_ideal(i,b2mk(zero),psk2b_pf(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in
  attacker(handshake_secret);
  (* ------ *)
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,true)) &&
  let early_secret = hmac_ideal(i,b2mk(zero),psk2b_pf(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
  attacker(client_wkh);
  (* ------ *)
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,true)) &&
  let early_secret = hmac_ideal(i,b2mk(zero),psk2b_pf(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
  let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
  attacker(client_fk);
  (* ------ *)
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,true)) &&
  let early_secret = hmac_ideal(i,b2mk(zero),psk2b_pf(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in
  attacker(server_wkh);
  (* ------ *)
  table(pre_shared_keys(c_dom,s_dom,h,id,psk,idP,true)) &&
  let early_secret = hmac_ideal(i,b2mk(zero),psk2b_pf(psk)) in
  let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
  let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in
  let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
  attacker(server_fk)
  [induction,fullSat]
.


let gen_dishonest_long_term_keys =
  !
  new idP:idProc;
  in(io,a:domain);
  new sk_d:privkey;
  event CompromisedLongTermKey(pk(sk_d));
  let crt = valid_cert(a,pk(sk_d)) in
  insert long_term_keys(a,sk_d,pk(sk_d),crt,idP);
  out(io,(sk_d,crt))
.

let gen_dishonest_pre_shared_keys =
  !
  new idP:idProc;
  let h_alg = id_hash(StrongHash,1) in
  in(io,(c_dom:domain,s_dom:domain));
  if is_strong_hash(h_alg) then
  new psk_d:preSharedKey;
  event CompromisedPsk(psk_d);
  let id = mk_idpsk(s_dom,h_alg,psk_d) in
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk_d,idP,false);
  out(io,psk_d)
.

(* let gen_dishonest_ech_config(g:group,h_alg:hash_alg,a_alg:aead_alg) =
  !
  in(io,o_dom:domain);
  new id: configId;
  new skR_d:bitstring;
  let pkR_d = dh_pub(g,skR_d) in
  event CompECHK(pkR_d);
  let config = ech_config(id,g,pkR_d,o_dom,h_alg,a_alg) in
  insert ech_configurations(config,skR_d);
  out(io,(config,skR_d))
. *)

(* Security properties *)

query psk,new_psk,old_psk:preSharedKey, s_pkey,s_pkey':pubkey,s_dom:domain,h:hash_alg,i,j:time;
  event(ServerNewTicket(psk,s_pkey,new_psk))@i && attacker(new_psk) ==>
    event(CompromisedLongTermKey(s_pkey)) ||
    event(CompromisedPsk(new_psk)) ||
    event(CompromisedPsk(psk)) ||
    psk = NoPsk ||
    (event(ServerNewTicket(old_psk,s_pkey',psk))@j && attacker(psk) && i > j)
.

(* 1-RTT handshake : secrecy and authentication queries *)

query cr,cr',sr,sr':bytes32,old_psk,psk,psk':preSharedKey,s_pkey,pk_srv,pk_srv':pubkey,cak,cak',sak,sak':aead_key,ems,ems',rms,rms':bitstring,i:nat;
  (* Secrecy *)
  event(ClientFinished(cr,sr,psk,pk_srv,cak,sak,ems,rms)) && attacker(cak) ==>
    event(CompromisedLongTermKey(pk_srv)) ||
    event(CompromisedPsk(psk)) ||
    event(ClientOffersHash(cr,id_hash(WeakHash,i))) ||
    event(ClientOffersGroup(cr,id_g(WeakDH,i)));

  event(ClientFinished(cr,sr,psk,pk_srv,cak,sak,ems,rms)) && attacker(psk) ==>
    psk = NoPsk || event(CompromisedPsk(psk));

  (* Authentication *)
  inj-event(ClientFinished(cr,sr,psk,pk_srv,cak,sak,ems,rms)) ==>
    inj-event(PreServerFinished(cr,sr,psk,pk_srv)) ||
    event(CompromisedLongTermKey(pk_srv)) ||
    event(CompromisedPsk(psk)) ||
    event(ClientOffersHash(cr,id_hash(WeakHash,i))) ||
    event(ClientOffersGroup(cr,id_g(WeakDH,i)));

  (* As an honest server can talk with a dishonest client, the ClientFinished
    is triggered only when the server uses an uncompromised PSK or
    request a client certificate. *)
  inj-event(ServerFinished(cr,sr,psk,pk_srv,cak,sak,ems,rms)) ==>
    inj-event(ClientFinished(cr,sr,psk,pk_srv,cak,sak,ems,rms)) ||
    event(CompromisedLongTermKey(pk_srv)) ||
    event(CompromisedPsk(psk)) ||
    (event(ServerNewTicket(old_psk,s_pkey,psk)) && attacker(psk)) ||
    psk = NoPsk ||
    event(ClientOffersHash(cr,id_hash(WeakHash,i))) ||
    event(ClientOffersGroup(cr,id_g(WeakDH,i)));

  event(ClientFinished(cr,sr,psk,pk_srv,cak,sak,ems,rms)) &&
  event(ServerFinished(cr',sr',psk',pk_srv',cak',sak',ems,rms')) ==>
    cr = cr' && sr = sr' && pk_srv = pk_srv';


  event(ClientFinished(cr,sr,psk,pk_srv,cak,sak,ems,rms)) &&
  event(ServerFinished(cr',sr',psk',pk_srv',cak',sak',ems',rms)) ==>
    cr = cr' && sr = sr' && pk_srv = pk_srv';

  event(ClientFinished(cr,sr,psk,pk_srv,cak,sak,ems,rms)) &&
  event(ServerFinished(cr',sr',psk',pk_srv',cak,sak,ems',rms')) ==>
    cr = cr' && sr = sr' && pk_srv = pk_srv'
.

(* Post Handshake Application Data: Secrecy and Authentication *)

restriction idP,idP':idProc,s_dom:domain,cr,cr',sr,sr':bytes32,psk,psk':preSharedKey,pk_srv,pk_srv':pubkey,st,st':stamp,n:nat,ad,ad',msg,msg':bitstring;
  event(ServerSends(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) && event(ServerSends(idP,cr',sr',psk',pk_srv',st',n,ad',msg')) ==> st = st';
  event(ClientSends(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) && event(ClientSends(idP,cr',sr',psk',pk_srv',st',n,ad',msg')) ==> st = st';

  event(ClientSends0(idP,cr,psk,st,n,ad,msg)) && event(ClientSends0(idP,cr,psk,st',n,ad',msg')) ==> st = st';

  event(ServerReceives(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) && event(ServerReceives(idP,cr',sr',psk',pk_srv',st',n,ad',msg')) ==> st = st';
  event(ClientReceives(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) && event(ClientReceives(idP,cr',sr',psk',pk_srv',st',n,ad',msg')) ==> st = st';

  event(ServerReceives0(idP,s_dom,cr,psk,st,n,ad,msg)) && event(ServerReceives0(idP',s_dom,cr',psk,st',n,ad',msg')) ==> st = st'
.

query idP,idP':idProc,s_dom:domain,cr,sr:bytes32,old_psk,psk:preSharedKey,s_pkey,pk_srv:pubkey,cak,sak:aead_key,ems,rms:bitstring,n,i:nat,ad,msg:bitstring,st,st':stamp;
  event(ClientSends(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) && attacker(msg) ==>
    event(CompromisedLongTermKey(pk_srv)) ||
    event(CompromisedPsk(psk)) ||
    event(ClientOffersHash(cr,id_hash(WeakHash,i))) ||
    event(ClientOffersGroup(cr,id_g(WeakDH,i))) ||
    event(ClientOffersAead(cr,id_aead(WeakAE,i)));

  (* As an honest server can talk with a dishonest client, the message is not deducible
    the server uses an uncompromised PSK or request a client certificate. *)
  event(ServerSends(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) && attacker(msg) ==>
    event(CompromisedLongTermKey(pk_srv)) ||
    event(CompromisedPsk(psk)) ||
    (event(ServerNewTicket(old_psk,s_pkey,psk)) && attacker(psk)) ||
    psk = NoPsk ||
    event(ServerChoosesHash(cr,sr,id_hash(WeakHash,i))) ||
    event(ServerChoosesGroup(cr,sr,id_g(WeakDH,i))) ||
    event(ServerChoosesAead(cr,sr,id_aead(WeakAE,i)));

  event(ClientReceives(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) && attacker(msg) ==>
    event(CompromisedLongTermKey(pk_srv)) ||
    event(CompromisedPsk(psk)) ||
    event(ServerChoosesHash(cr,sr,id_hash(WeakHash,i))) ||
    event(ServerChoosesGroup(cr,sr,id_g(WeakDH,i))) ||
    event(ServerChoosesAead(cr,sr,id_aead(WeakAE,i)));

  event(ClientSends0(idP,cr,psk,st,n,ad,msg)) && attacker(msg) ==>
    event(CompromisedPsk(psk)) ||
    event(ClientOffersAead(cr,id_aead(WeakAE,i)));

  inj-event(ClientReceives(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) ==>
    inj-event(ServerSends(idP',cr,sr,psk,pk_srv,st',n,ad,msg)) ||
    event(CompromisedLongTermKey(pk_srv)) ||
    event(CompromisedPsk(psk)) ||
    event(ServerChoosesHash(cr,sr,id_hash(WeakHash,i))) ||
    event(ServerChoosesGroup(cr,sr,id_g(WeakDH,i))) ||
    event(ServerChoosesAead(cr,sr,id_aead(WeakAE,i)));

  inj-event(ServerReceives(idP,cr,sr,psk,pk_srv,st,n,ad,msg)) ==>
    inj-event(ClientSends(idP',cr,sr,psk,pk_srv,st',n,ad,msg)) ||
    event(CompromisedLongTermKey(pk_srv)) ||
    event(CompromisedPsk(psk)) ||
    (event(ServerNewTicket(old_psk,s_pkey,psk)) && attacker(psk)) ||
    psk = NoPsk ||
    event(ServerChoosesHash(cr,sr,id_hash(WeakHash,i))) ||
    event(ServerChoosesGroup(cr,sr,id_g(WeakDH,i))) ||
    event(ServerChoosesAead(cr,sr,id_aead(WeakAE,i)));

  inj-event(ServerReceives0(idP,s_dom,cr,psk,st,n,ad,msg)) ==>
    inj-event(ClientSends0(idP',cr,psk,st',n,ad,msg)) ||
    event(CompromisedPsk(psk)) ||
    (event(ServerNewTicket(old_psk,s_pkey,psk)) && attacker(psk)) ||
    event(ClientOffersAead(cr,id_aead(WeakAE,i)))
.

query idP,idP':idProc,cr,sr:bytes32,psk:preSharedKey,s_pkey,c_pkey:pubkey,cak,sak:aead_key,ems,rms:bitstring,n,i:nat,ad,msg':bitstring,req_rand:bitstring,st,st':stamp;
  inj-event(ClientFinishedPH(cr,sr,psk,s_pkey,req_rand,c_pkey)) ==>
    inj-event(ServerRequestPH(cr,sr,psk,s_pkey,req_rand)) ||
    event(CompromisedLongTermKey(s_pkey)) ||
    event(CompromisedPsk(psk)) ||
    event(ServerChoosesHash(cr,sr,id_hash(WeakHash,i))) ||
    event(ServerChoosesGroup(cr,sr,id_g(WeakDH,i))) ||
    event(ServerChoosesAead(cr,sr,id_aead(WeakAE,i)));

  inj-event(ServerFinishedPH(cr,sr,psk,s_pkey,req_rand,c_pkey)) ==>
    inj-event(ClientFinishedPH(cr,sr,psk,s_pkey,req_rand,c_pkey)) ||
    event(CompromisedLongTermKey(s_pkey)) ||
    event(CompromisedLongTermKey(c_pkey)) ||
    event(CompromisedPsk(psk)) ||
    event(ServerChoosesHash(cr,sr,id_hash(WeakHash,i))) ||
    event(ServerChoosesGroup(cr,sr,id_g(WeakDH,i))) ||
    event(ServerChoosesAead(cr,sr,id_aead(WeakAE,i)))
.

process
  let tls_h = id_hash(StrongHash,1) in
  let tls_a = id_aead(StrongAE,1) in
  let tls_g = id_g(StrongDH,1) in
  let ech_h = id_hash(StrongHash,2) in
  let ech_a = id_aead(StrongAE,2) in
  let ech_g = id_g(StrongDH,2) in
  (
    (* Generates the keys *)
      gen_dishonest_long_term_keys
    | gen_dishonest_pre_shared_keys
    | gen_honest_key
    | main_process
  ) | (
    (* TLS client *)
    !
    in(io,s_dom:domain) [precise];
    in(io,c_dom:domain) [precise];
    (* in(io,tls_h:hash_alg) [precise];
    (* if is_strong_hash(tls_h) then *)
    in(io,tls_a:aead_alg) [precise];
    if is_strong_aead(tls_a) then
    in(io,tls_g:group)[precise];
    if is_strong_group(tls_g) then *)
    new id_client[]:idProc;

    in(io,use_psk:bool)[precise];
    (* let send_kex = true in *)
    in(io,send_kex:bool) [precise];

    in(io,comp_psk:bool) [precise];

    standard_client(id_client,use_psk,comp_psk,send_kex,c_dom,s_dom,tls_g,tls_h,tls_a)
  ) | (
    !
    (* Server *)
    (* in(io,use_ech:bool); *)
    in(io,s_dom:domain)[precise];
    (* in(io,tls_h:hash_alg)[precise];
    if is_strong_hash(tls_h) then
    in(io,tls_a:aead_alg)[precise];
    if is_strong_aead(tls_a) then
    in(io,tls_g:group)[precise];
    if is_strong_group(tls_g) then *)
    let use_ech=false in
    (* in(io,use_ech:bool); *)
    in(io,use_psk:bool) [precise];
    (* let req_cert = false in *)
    in(io,req_cert:bool) [precise];


    server(use_ech,use_psk,req_cert,
      s_dom,
      tls_g,tls_h,tls_a,
      tls_g,tls_h,tls_a,
      empty_extra_ext
    )
  )
