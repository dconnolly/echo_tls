set removeEventsForLemma = true.

(* Restriction for equivalence *)

restriction x,x':bitstring; event(Same(diff[x,x'])) ==> x = x'.

fun idClientDiff(seed):idProc [private].

restriction s:seed,s_pkey:pubkey;
  event(Client_Cert_server(idClientDiff(s),s_pkey)) && event(CompromisedLtk(s_pkey)).

restriction s:seed;
  event(CompromisedPskDiff(idClientDiff(s))).

restriction
  dom1,dom1',dom2,dom2':domain,idP,idP':idProc;
  event(Selected_ltk(diff[dom1,dom1'],diff[dom2,dom2'],diff[idP,idP'])) ==>
    (* The entries taken from the table should correspond to the requested domains *)
    dom1 = dom2 &&  (* On the left side *)
    dom1' = dom2' && (* On the right side *)
    (
      (* If the requested domains on the left and on the right are the same, we use the same
         idProc to match them. No condition when the requested domains are different *)
      (dom1 = dom1' && idP = idP') || (dom1 <> dom1')
    )
.

restriction
  dom1,dom1',dom2,dom2':domain, idP,idP':idProc, s:seed, safe,safe':bool;
  event(Selected_psk(diff[dom1,dom1'],diff[dom2,dom2'],diff[idP,idP'],diff[safe,safe'])) ==>
    (* The entries taken from the table should correspond to the requested domains *)
    dom1 = dom2 &&
    dom1' = dom2' &&
    (
      (* If the requested domains on the left and on the right are the same, we use the same
         idProc to match them unless one of them is idClientDiff. No condition when the requested domains are different *)
      (dom1 <> dom1') ||
      (dom1 = dom1' &&
        (
          (* We match an inserted key at idClientDiff with an uncompromised key, otherwise we use
             the key that was generated at the same time. Note that the mathing to an uncompromised
             key is necessary as we prove in the lemma below that all keys inserted at idClientDiff
             are uncompromised.
          *)
          (idP = idClientDiff(s) && safe' = true) ||
          (idP' = idClientDiff(s) && safe = true) ||
          idP = idP'
        )
      )
    )
.

(* We request for the matching that when the requested server is the same on both side,
  and that we already used a psk "pskL" and "pskR" respectively to match them then
  if a new session want to use the psk "pskL" on the left (resp. "pskR" on the right),
  we should match it again with the psk "pskR" on the right (resp. "pskL" on the left).

  Otherwise the attacker would be able to distinguish two session of a client using
  the same psk vs two sessions of the same client using different psk just by looking
  at their ID in the client hello message.

  Note that we do not prevent resuing multiple time the same psk. We only build the equivalence
  relation to ensure that if the same psk was used multiple times on one side then
  we match it by another psk also used multiple times.
*)

restriction dom:domain,idP,idP',idP'':idProc,safe,safe',safe'':bool;
  event(Selected_psk(dom,dom,diff[idP,idP'],diff[safe,safe'])) &&
  event(Selected_psk(dom,dom,diff[idP,idP''],diff[safe,safe''])) ==>
  idP' = idP'';

  event(Selected_psk(dom,dom,diff[idP',idP],diff[safe',safe])) &&
  event(Selected_psk(dom,dom,diff[idP'',idP],diff[safe'',safe])) ==>
  idP' = idP''.

(* We restrict our traces where the process on which we look at the privacy of ClientA/ClientB uses psk that
  are one time used and uncompromised. For the uncompromised keys, they can either be freshly generated
  or  coming from a ticket *)
restriction
  ipsk,ipsk1,ipsk2:preSharedKey,idP:idProc,s:seed,safe,safe1,safe2:bool;
  (* One time used property *)
  event(Selected_one_time_used_psk(idClientDiff(s),diff[ipsk,ipsk1],diff[safe,safe1])) &&
  event(Selected_one_time_used_psk(idP,diff[ipsk,ipsk2],diff[safe,safe2])) ==> idP = idClientDiff(s);
  event(Selected_one_time_used_psk(idClientDiff(s),diff[ipsk1,ipsk],diff[safe1,safe])) &&
  event(Selected_one_time_used_psk(idP,diff[ipsk2,ipsk],diff[safe2,safe])) ==> idP = idClientDiff(s);
  (* Ucompromised property *)
  event(Selected_one_time_used_psk(idClientDiff(s),diff[ipsk1,ipsk2],diff[safe1,safe2])) ==> safe1 = true && safe2 = true
.

let swap_long_term_keys =
  !
  get long_term_keys(dom1,sk1,pk1,cert1,idP1) in
  event Same(id2b(idP1));
  get long_term_keys(dom2,sk2,pk2,cert2,idP2) in
  event Same(id2b(idP2));
  insert long_term_keys(diff[dom1,dom2],diff[sk1,sk2],diff[pk1,pk2],diff[cert1,cert2],diff[idP1,idP2]);
  insert long_term_keys(diff[dom2,dom1],diff[sk2,sk1],diff[pk2,pk1],diff[cert2,cert1],diff[idP2,idP1])
.

let swap_pre_shared_keys =
  !
  get pre_shared_keys(c_dom1,s_dom,h_alg1,id1,psk1,idP1,safe1) in
  event Same(id2b(idP1));
  get pre_shared_keys(c_dom2,=s_dom,h_alg2,id2,psk2,idP2,safe2) in
  event Same(id2b(idP2));
  insert pre_shared_keys(diff[c_dom1,c_dom2],s_dom,diff[h_alg1,h_alg2],diff[id1,id2],diff[psk1,psk2],diff[idP1,idP2],diff[safe1,safe2]);
  insert pre_shared_keys(diff[c_dom2,c_dom1],s_dom,diff[h_alg1,h_alg2],diff[id2,id1],diff[psk2,psk1],diff[idP2,idP1],diff[safe2,safe1])
.

(* Lemma to help the proof *)

lemma c_dom,c_dom',s_dom,s_dom',s_dom'':domain,h_alg',h_alg,h_alg'':hash_alg,id,id',id'':identityPsk,ipsk,ipsk':preSharedKey,s:seed,
  c_dom1,c_dom1',c_dom2,c_dom2',s_dom1,s_dom1',s_dom2,s_dom2',c_dom3,c_dom3',c_dom4,c_dom4',s_dom3,s_dom3',s_dom4,s_dom4':domain,
  h_alg1,h_alg2:hash_alg,id1,id1',id2:identityPsk,ipsk1,ipsk1',ipsk'',ipsk2:preSharedKey,idP,idP',idP1,idP2,idP1':idProc,
  safe,safe',safe1,safe2:bool, i,i':nat,
  id_c,id_s:idProc, new_psk1,new_psk1',new_psk2,new_psk2',psk,psk':preSharedKey,cr,sr:bytes32, is_rand:bool
  ;
  attacker(diff[mk_idpsk(s_dom,h_alg,ipsk),mk_idpsk(s_dom',h_alg',ipsk')]) ==>
    s_dom = s_dom' &&
    h_alg = h_alg' && ipsk <> NoPsk && ipsk <> b2psk(zero) && ipsk' <> NoPsk && ipsk' <> b2psk(zero)
    ;
  attacker(diff[mk_idpsk(s_dom,h_alg,ipsk),mk_idpsk(s_dom',h_alg',ipsk')]) && attacker(diff[ipsk,ipsk'']) ==> ipsk' = ipsk'';
  attacker(diff[mk_idpsk(s_dom,h_alg,ipsk),mk_idpsk(s_dom',h_alg',ipsk')]) && attacker(diff[ipsk'',ipsk']) ==> ipsk = ipsk'';

  (* -------------- *)

  attacker(diff[mk_idpsk(s_dom,h_alg,ipsk),mk_idpsk(s_dom',h_alg',ipsk')]) && attacker(diff[s_dom,s_dom'']) ==> s_dom' = s_dom'';
  attacker(diff[mk_idpsk(s_dom,h_alg,ipsk),mk_idpsk(s_dom',h_alg',ipsk')]) && attacker(diff[s_dom'',s_dom]) ==> s_dom = s_dom'';

  (* -------------- *)

  event(Selected_psk(diff[c_dom,c_dom'],diff[c_dom,c_dom'],diff[idP,idP'],diff[safe,safe'])) &&
  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[mk_idpsk(s_dom,h_alg,ipsk),id'],diff[ipsk,ipsk'],diff[idP,idP'],diff[safe,safe'])) ==>
    id' = mk_idpsk(s_dom',h_alg',ipsk');

  event(Selected_psk(diff[c_dom,c_dom'],diff[c_dom,c_dom'],diff[idP,idP'],diff[safe,safe'])) &&
  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,mk_idpsk(s_dom',h_alg',ipsk')],diff[ipsk,ipsk'],diff[idP,idP'],diff[safe,safe'])) ==>
    id = mk_idpsk(s_dom,h_alg,ipsk);

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],idP,diff[safe,safe'])) &&
  attacker(diff[id,id'']) ==> id' = id'';
  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],idP,diff[safe,safe'])) &&
  attacker(diff[id'',id']) ==> id = id'';

  (* -------------- *)

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],diff[idP,idP'],diff[safe,safe'])) ==>
    s_dom = s_dom' &&
    h_alg = id_hash(StrongHash,i) &&
    h_alg' = id_hash(StrongHash,i) &&
    (attacker(diff[id,id'']) || id = mk_idpsk(s_dom,h_alg,ipsk));
  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],diff[idP,idP'],diff[safe,safe'])) ==>
    s_dom = s_dom' &&
    h_alg = id_hash(StrongHash,i) &&
    h_alg' = id_hash(StrongHash,i) &&
    (attacker(diff[id'',id']) || id' = mk_idpsk(s_dom',h_alg',ipsk'));

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],idP,diff[safe,safe'])) ==>
    s_dom = s_dom' &&
    h_alg = id_hash(StrongHash,i) &&
    h_alg' = id_hash(StrongHash,i) &&
    safe = safe' &&
    (attacker(diff[id,id']) || (id = mk_idpsk(s_dom,h_alg,ipsk) && id' = mk_idpsk(s_dom',h_alg',ipsk')));

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,mk_idpsk(s_dom',h_alg',ipsk')],diff[ipsk,ipsk'],idP,diff[safe,safe'])) ==>
    id = mk_idpsk(s_dom,h_alg,ipsk);
  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[mk_idpsk(s_dom,h_alg,ipsk),id'],diff[ipsk,ipsk'],idP,diff[safe,safe'])) ==>
    id' = mk_idpsk(s_dom',h_alg',ipsk');

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],diff[idP,idP'],diff[safe,safe'])) &&
  attacker(diff[ipsk,ipsk'']) ==>  safe <> true;

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],diff[idP,idP'],diff[safe,safe'])) &&
  attacker(diff[ipsk'',ipsk']) ==>  safe' <> true;

  (* If same idP and one ipsk deducible then both are deducible *)
  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],idP,diff[safe,safe'])) &&
  attacker(diff[ipsk,ipsk'']) ==>  ipsk' = ipsk'' && safe <> true && safe' <> true;

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],idP,diff[safe,safe'])) &&
  attacker(diff[ipsk'',ipsk']) ==>  ipsk = ipsk'' && safe <> true && safe' <> true;

  (* Insertion with id_client_diff cannot be be deducible *)

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],diff[idClientDiff(s),idP],diff[safe,safe'])) &&
  attacker(diff[ipsk,ipsk'']);

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],diff[idP,idClientDiff(s)],diff[safe,safe'])) &&
  attacker(diff[ipsk'',ipsk']);

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[new_psk1,new_psk1'],idP,diff[safe,safe'])) &&
  event(Client_new_PSK(id_c,diff[new_psk1,new_psk2']))
   ==>
    new_psk1' = new_psk2' && idP = id_c;


  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[new_psk1,new_psk1'],idP,diff[safe,safe'])) &&
  event(Client_new_PSK(id_c,diff[new_psk2,new_psk1']))
   ==>
    new_psk1 = new_psk2 && idP = id_c;

  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[new_psk1,new_psk1'],idP,diff[safe,safe'])) &&
  event(Server_new_PSK(id_s,diff[new_psk1,new_psk2']))
   ==>
    new_psk1' = new_psk2';


  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[new_psk1,new_psk1'],idP,diff[safe,safe'])) &&
  event(Server_new_PSK(id_s,diff[new_psk2,new_psk1']))
   ==>
    new_psk1 = new_psk2
  [induction,fullSat]
.

nounif s_dom,s_dom':domain, h_alg,h_alg':hash_alg, psk,psk':preSharedKey;
  attacker(mk_idpsk(diff[*s_dom,*s_dom'],diff[*h_alg,*h_alg'],diff[*psk,*psk'])) [ignoreAFewTimes]
.

nounif c_dom,c_dom',s_dom,s_dom':domain,h,h':hash_alg,id,id':identityPsk,x,x':preSharedKey,safe,safe':bool,idP,idP':idProc;
  table(pre_shared_keys( diff[*c_dom,*c_dom'], diff[*s_dom,*s_dom'], diff[*h,*h'], diff[*id,*id'], diff[*x,*x'], diff[*idP,*idP'], diff[ *safe, *safe'])) [ignoreAFewTimes]
.

(* Axioms GSVerif like *)

axiom id,id1,id2:idProc,k,k',k1,k2:preSharedKey;
  event(Client_new_PSK(diff[id,id1],diff[k,k1])) && event(Client_new_PSK(diff[id,id2],diff[k',k2])) ==> k = k';
  event(Client_new_PSK(diff[id1,id],diff[k1,k])) && event(Client_new_PSK(diff[id2,id],diff[k2,k'])) ==> k = k'
.


expand macro_ech_client(false,false,run_ech_client).
expand macro_standard_client(false,run_tls_client).

expand macro_standard_client(true,run_tls_client_diff).

process
  (
    (* Generates the keys *)
      gen_honest_key
    | gen_dishonest_key
    | all_internal_processes
  ) | (
    (* TLS*)
    !
    new id_tls_client:idProc;
    (* Domains *)
    in(io,s_dom:domain);
    event Same(d2b(s_dom));
    in(io,c_dom:domain);
    event Same(d2b(c_dom));

    run_tls_client(id_tls_client,c_dom,s_dom)
  ) | (
    if clients_with_ech then
    (* ECH client *)
    !
    new id_client:idProc;
    (* Domains *)
    in(io,backend_dom:domain);
    event Same(d2b(backend_dom));
    in(io,frontend_dom:domain);
    event Same(d2b(frontend_dom));
    in(io,c_dom:domain);
    event Same(d2b(c_dom));

    get ech_configurations(ech_config(id,g,pkR,=frontend_dom,h_alg,a_alg),skR) in
    let ech_conf = ech_config(id,g,pkR,frontend_dom,h_alg,a_alg) in

    run_ech_client(id_client,empty_extra_ext,c_dom,backend_dom,ech_conf)
  ) | (
    !
    (* Server *)
    new id_server:idProc;
    in(io,s_dom:domain);
    event Same(d2b(s_dom));
    run_server(id_server,s_dom,empty_extra_ext)
  ) | (
    (* TLS client with Diff *)
    !
    (* Domains *)
    in(io,ClientA:domain) [precise];
    in(io,ClientB:domain) [precise];
    let c_dom = diff[ClientA,ClientB] in
    in(io,s_dom:domain) [precise];
    event Same(d2b(s_dom));
    new s:seed;
    let id_client = idClientDiff(s) in

    run_tls_client_diff(id_client,c_dom,s_dom)
  )
