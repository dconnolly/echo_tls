free io:channel.
const zero: bitstring.

(********************************************************)
(* Authenticated Encryption with Additional Data *)
(* extended with with weak/strong algorithms: See Lucky13, Beast, RC4 *)
(********************************************************)

(* Aead algorithm. Abstracted into whether we consider strong or weak security
    guarantees. *)
type aead_alg.
const WeakAE, StrongAE: aead_alg.

type aead_key.
fun b2ae(bitstring):aead_key [data].

fun aead_enc(aead_alg, aead_key, bitstring, bitstring, bitstring): bitstring.
fun aead_forged(bitstring,bitstring): bitstring.

fun aead_dec(aead_alg, aead_key, bitstring, bitstring, bitstring): bitstring
reduc forall a:aead_alg, k:aead_key, n,p,ad:bitstring;
  aead_dec(a, k, n, ad, aead_enc(a, k, n, ad, p)) = p
otherwise forall a:aead_alg, k:aead_key, n,p,p',ad,ad':bitstring;
  aead_dec(WeakAE, k, n, ad, aead_forged(p,aead_enc(WeakAE, k, n, ad', p'))) = p.

fun aead_leak(bitstring):bitstring
reduc forall k:aead_key, n,ad,x:bitstring;
  aead_leak(aead_enc(WeakAE,k,n,ad,x)) = x.

(********************************************************)
(* Diffie-Hellman, modeled as a KEM *)
(* Include a small/bad subgroup attacks. *)
(********************************************************)

type group.
const WeakDH: group [data].
const StrongDH: group [data].

type element.
const guessable: element.
fun e2b(element): bitstring [data] (* TODO: e2b could be a type convertor ? *).

(* Key Generation *)
fun dh_pub(group,bitstring): element.

fun discrete_log(element): bitstring
reduc forall x:bitstring;
  discrete_log(dh_pub(WeakDH,x)) = x.

letfun dh_keygen(g:group) =
  new x:bitstring;
  let gx = dh_pub(g,x) in
  (x,gx).

(* Encap/Decap Functionality *)
fun dh_encap_fun(group,element,element):element.
fun dh_decap_fun(group,element,bitstring): element
reduc forall g:group, x:bitstring, gxy:element;
  dh_decap_fun(g,dh_encap_fun(g,dh_pub(g,x),gxy),x) = gxy.

(* Generate then Encap *)
letfun dh_encap(g:group,gx:element) =
  new gxy:element;
  (gxy, dh_encap_fun(g,gx,gxy)).

(* Decap: never fails *)
letfun dh_decap(g:group,gy:element,x:bitstring) =
  let gxy = dh_decap_fun(g,gy,x) in
    gxy
  else (
    new gxy:element;
    gxy).

(**************************************************************)
(* Hash Functions, including those with collisions. See SLOTH *)
(**************************************************************)

type hash_alg.
const StrongHash: hash_alg [data].
const WeakHash: hash_alg [data].

const collision:bitstring [data].
fun hash_ideal(bitstring):bitstring.

fun hash(hash_alg,bitstring): bitstring
reduc forall x:bitstring;
      hash(WeakHash,x) = collision
otherwise forall x:bitstring;
      hash(StrongHash,x) = hash_ideal(x).

(********************************************************)
(* HPKE *)
(********************************************************)

(* Vincent : I'm trying to match a bit more closely the RFC for now compared
   to the equation provided.*)

(* We consider here the HPKE without pre shared key so the functions are
   simplified to remove all references to pre shared key. *)

type HpkeMode.
const R,S:HpkeMode

type HpkeLabel.
const info_hash_lbl,secret_lbl,key_lbl,base_nonce_lbl,exp_lbl:HpkeLabel.

type HpkeContext.
fun hpke_context(mode,ae_key,bitstring,bitstring):HpkeContext [data].

const nonce_for_seal_open:bitstring. (* Temporary until I understant how to model
  the nonce that are generated from the internal sequence *)

letfun kpke_seal(context:HpkeContextS,aad:bitstring,pt:bitstring) =
  let hpke_context(=S,key,nonce,exporter) = context in
  aead_enc(StrongAE,key,nonce_for_seal_open,aad,pt).

letfun hpke_open(context:HpkeContextR,aad:bitstring,ct:bitstring) =
  let hpke_context(=R,key,nonce,exporter) = context in
  aead_dec(StrongAE,key,nonce_for_seal_open,aad,pt).


letfun hpke_key_schedule(m:mode,shared_secret:element,info:bitstring) =
  let info_hash = hkdf_extract(zero,(info_hash_lbl,info)) in
  let secret = hkdf_extract(shared_secret,(secret_lbl,zero)) in

  let key = hkdf_expand_label(secret,key_lbl,info_hash) in
  let base_nonce = hkdf_expand_label(secret,base_nonce_lbl,info_hash) in
  let exporter_secret = hkdf_expand_label(secret,exp_lbl,info_hash) in

  hpke_context(m,ae_key,base_nonce,exporter_secret).

(* SetupBaseS and SetupBaseR (5.1.1 in RFC HPKE )*)

letfun hpke_setup_base_S(pkR:element,info:bitstring) =
  let (shared_secret:element,enc:element) = dh_encap(StrongDH,pkR) in
  (enc,key_schedule_S(S,shared_secret,info)).

letfun hpke_setup_base_R(enc:element,skR:element,info:bitstring) =
  let shared_secret:element = dh_decap(StrongDH,enc,skR) in
  (enc,key_schedule_R(R,shared_secret,info)).

(***************************************
  The Encrypted Client Hello functions
****************************************)

(*******************************)
(* Echo Configuration          *)

(* Data structure of ECHCipherSuite:
    We consider all elements of [ECHCipherSuite] of the RFC (Section 4.):
      - kdf_id of type [HpkeKdfId] in RFC
      - aead_id of type [AeadId] in RFC
    "Corresponds to the list of HPKE KDF and AEAD identifier pairs clients
      can use for encrypting ClientHelloInner."
*)

type HpkeKdfId.
type AeadId = ae_alg.
type HpkeSymmetricCipherSuite.
fun hpke_symmetric_cipher_suite(HpkeKdfId,AeadId):HpkeSymmetricCipherSuite [data].

(* Data structure of HpkeKeyConfig
    We consider all elements of [HpkeKeyConfig] of the RFC (Section 4.):
      - config_id of type [uint8] in RFC ([nat] in this model)
      - kem_id of type [HpkeKemId] in RFC
      - public_key of type [HpkePublicKey] in RFC (which is an alias of [element] in this model)
      - cipher_suites of type [HpkeSymmetricCipherSuite] in RFC
*)

type domain
type HpkeKemId
type HpkePublicKey = element.
type HpkeKeyConfig.
fun hpke_key_config(nat,HpkeKemId,HpkePublicKey,HpkeSymmetricCipherSuite):HpkeKeyConfig [data].

(* Data structure of ECHConfigContents (Section 4 of ECH RFC)
    We only consider the following elements:
      - key_config of type [HpkeKeyConfig]
      - public_name of type [opaque] in RFC ([domain] in this model)
*)

type ECHConfigContents.
fun ECH_config_contents(HpkeKeyConfig,domain):ECHConfigContents [data].

(* Data structure of ECHConfig (Section 4 of ECH RFC)
    We consider the following elements:
      - version of type [uint16] in RFC ([ECH_version] in this model. Could be aliased
        by natural number maybe ?)
      - We consider a single ECHConfigContents
*)

type ECH_version.
type ECHConfig.
fun ECH_config(ECH_version,ECHConfigContents):ECHConfig [data].

(* Some useful access functions *)
let get_public_key(ech_config:ECHConfig) =
  let ECH_config(v,ECH_config_contents(hpke_key_config(config_id,kemid,public_key,ciphersuite),domain)) = ech_config in
  public_key.

let get_hpke_cipher_suite(ech_config:ECHConfig) =
  let ECH_config(v,ECH_config_contents(hpke_key_config(config_id,kemid,public_key,ciphersuite),domain)) = ech_config in
  ciphersuite.

let get_config_id(ech_config:ECHConfig) =
  let ECH_config(v,ECH_config_contents(hpke_key_config(config_id,kemid,public_key,ciphersuite),domain)) = ech_config in
  config_id.

(*****************************************************)
(* The "encrypted_client_hello" Extension. Section 5 *)

type EncryptedClientHelloExt.

(* Represents the absence of extension *)
const none_ECHExt: EncryptedClientHelloExt

(* This extension should only occur in the ClientHelloInner. *)
const ech_is_inner: EncryptedClientHelloExt.

(* This extension should only occur in the ClientHelloOuter. *)
(* This includes the following element
    - cipher_suite of type [HpkeSymmetricCipherSuite];
    - config_id of type [uint8] in RFC ([nat] in this model). Should be the same
      as in the ECH config.
    - enc of type [opaque] in RFC ([element] in this model). It's the The HPKE encapsulated key
        (TODO: Maybe put the type of the HPKE type)
    - payload of type [opaque] in RFC ([bitstring] in this model).
        (TODO: It should be a cipher using HPKE. Maybe put the corresponding type)
*)
fun client_ECH(HpkeSymmetricCipherSuite,nat,element,bitstring): EncryptedClientHelloExt [data].

(***************************************
  TLS message formats
****************************************)

type TLS_version.
const TLS12, TLS13: version.

(* COMMENT Vincent: We keep for now almost the same structure as the original
  file to reuse as much as possible but it would be nicer if we get as close as
  possible from the RFC

Example of possible new data representation:

type ClientHello.
fun client_hello(TLS_version,random,CipherSuite,SniExt,EncryptedClientHelloExt,PreSharedKeyExt):ClientHello

We would use that rather than the current function nego.
*)

type kex_alg.
fun RSA(rsa_alg):kex_alg [data].
fun DHE(group):kex_alg [data].
fun DHE_13(group,element): kex_alg [data].

(* The SNI extension *)

type sni.
fun SNI(domain): sni [data]. (* QUESTION : Would the argument of SNI be
  considered as an element of type domain ? *)

(* The Pre Shared Key extension *)
type psk_type.
fun Binder(bitstring): psk_type [data].
fun NoBinder(): psk_type [data].

(* The function negotiation is extended to contain the ECHO extension *)

type params.
fun nego(TLS_version,kex_alg,hash_alg,ae_alg,sni,EncryptedClientHelloExt,psk_type): params [data].

type msg.
fun msg2bytes(msg):bitstring [typeConverter].
fun CH(random,params):msg [data].
fun SH(random,params):msg [data].
fun EE(random):msg [data]. (* Just for ESNI nonce ; can have other extensions in general*)
fun CRT(bitstring,pubkey):msg       [data].
fun SKE(group,element,bitstring):msg [data].
fun CKE(bitstring): msg [data].
fun CV(bitstring):msg [data].
fun FIN(bitstring):msg [data].

(*****************************************************)
(* Authenticating the ClientHelloOuter. Section 5.1 *)

(* TODO: Some sentence that I'm not sure to understand yet :
  "passing it in as the associated data for HPKE sealing and opening
   operations."
*)

type ClientHelloOuterAAD.

fun client_hello_outer_AAD(HpkeSymmetricCipherSuite,nat,element,msg):ClientHelloOuterAAD [data].

letfun mk_client_hello_outer_AAD(client_hello_outer:msg) =
  let CH(r,nego(version,k_alg,h_alg,ae_alg,sni,echo,psk)) = client_hello_outer in
  let client_ECH(cipher_suite,config_id,enc,payload) = echo in

  (* The client_hello_outer with extension removed *)
  let client_hello_outer' = CH(r,nego(version,k_alg,h_alg,ae_alg,sni,none_ECHExt,psk)) in

  client_hello_outer_AAD(cipher_suite,config_id,enc,client_hello_outer').

(********************************************
  The Client side of ECHO (Section 6 of RFC)
*********************************************)

const tls_ech_str:bitstring.

letfun mk_encrypted_client_hello(
  o_g:group,o_domain:domain,o_hash:hash_alg,o_aead:aead_alg,
  i_g:group,i_domain:domain,i_hash:hash_alg,i_aead:aead_alg,
  ech_config:ECHConfig
  ) =
  (* Vincent : I think some of the arguments should be contained within the ECHConfig
    and/or check that they correspond to the ech_config given as argument. Most probably:
      - o_domain
      - i_domain
      - o_aead and i_aead used in TLS should probably also match the one in ECHConfig.
  *)

  (* Retrieve the pre-shared key *)
  (* TODO : Shouldn't the preshared key be parametrised in the table by the user / server ? *)
  get preSharedKeys(a,sn,tkt,psk) in


  (* Client Hello Inner *)
  let (i_x:bitstring,i_gx) = dh_keygen(i_g) in
  let (early_secret:bitstring,kb:mac_key) = kdf_es(psk) in (* For Pre Shared Keys *)
  new i_r:random;
  let i_offer1 = nego(TLS13,DHE_13(i_g,i_gx),i_hash,i_aead,SNI(i_domain),ech_is_inner,Binder(zero)) in
  let preshared_ext = Binder(hmac(StrongHash,kb,msg2bytes(CH(i_r,i_offer1)))) in
  let i_offer2 = nego(TLS13,DHE_13(i_g,i_gx),i_hash,i_aead,i_sni,ech_is_inner,preshared_ext) in
  let i_client_hello = CH(i_r,i_offer2) in

  (* TODO : The Encoded Client Hello Inner is not done yet. Need to understand what to do *)

  (* Generation of the Client Hello Outer with a dummy ECHO extension *)
  let (o_x:bitstring,o_gx) = dh_keygen(o_g) in
  new o_r:random;
  let o_offer1 = nego(TLS13,DHE_13(o_g,o_gx),o_hash,o_aead,SNI(o_domain),none_ECHExt,Binder(zero)) in
  let o_client_hello1 = CH(o_r,o_offer1) in

  let client_hello_AAD = mk_client_hello_outer_AAD(o_client_hello1) in

  (* Generating the HPKE Context (Section 6.1 in RFC)*)
  let pkR = get_public_key(ech_config) in
  let (enc,context) = hpke_setup_base_S(pkR,(tls_ech_str,ECHConfig)) in
  let payload = kpke_seal(context,client_hello_AAD,i_client_hello) in

  let cipher_suite = get_hpke_cipher_suite(ech_config) in
  let config_id = get_config_id(ech_config) in

  let ech_ext = client_ECH(cipher_suite,config_id,enc,payload) in

  (* We plug the Echo extension in the ClientHelloOuter to generate the final client hello message.
      TODO : Unless i'm mistaken, i need to use the same random, hash id, etc as the ones used in
      to generate the client hello AAD.
   *)
  let offer = nego(TLS13,DHE_13(o_g,o_gx),o_hash,o_aead,SNI(o_domain),ech_ext,Binder(zero)) in
  CH(o_r,offer).

(*****************************************************
  The Client-Facing Server in ECHO (Section 7.1 of RFC)
******************************************************)

let ECH_Client_Facing_Server(ech_config:ECHConfig,skR:element,client_hello_outer:msg) =

  (* Verify that the ECH_config corresponds to the client hello message and that
    the decryption works.
    If the verification does not match then the server should continue the
    connection with the ClientHelloOuter. In RFC it is added that:
      This connection proceeds as usual, except the server MUST include the
      "encrypted_client_hello" extension in its EncryptedExtensions with
      the "retry_configs" field set to one or more ECHConfig structures
      with up-to-date keys.
  *)
  let config_id = get_config_id(ech_config) in
  let cipher_suite = get_hpke_cipher_suite(ech_config) in

  let CH(r,offer) = client_hello_outer in
  let nego(=TLS13,DHE_13(g,gx),hash_alg,aead_alg,sni_ext,ech_ext,pre_shared_key) = offer in
  let (=cipher_suite,=config_id,enc,payload) = ech_ext in

  (* QUESTION : In the RFC it is written that :
      The server verifies that the ECHConfig supports the cipher suite
     indicated by the ClientECH.cipher_suite and that the version of ECH
     indicated by the client matches the ECHConfig.version.

     It's ok for the cipher suite as it is included in the client hello but it's
     not the case for the version, so where does the client indicates the version
     of ECHO used ?
    *)

  let client_hello_AAD = mk_client_hello_outer_AAD(client_hello_outer) in
  let context = hpke_setup_base_R(enc,(tls_ech_str,ECHConfig)) in
  let ch_inner = hpke_open(context,ch_outer_AAD,payload) in

  (* The verification succeed hence the server must forward the message to
     the backend server.

     Question : Is the forwarding done on a public channel ? private channel ?
     If it's on a public channel, should we consider that the attacker will do
     the forwarding itself if he wants to so we don't need to write anything
     anymore.
  *)
  out(io,ch_inner)
.



(*****************************************************
  The Backend Server in ECHO (Section 7.2 of RFC)
******************************************************)

let ECH_Backend_Server = 0.



(*****************************************************
  The main protocol
******************************************************)

let ECH_client(
  o_g:group,o_domain:domain,o_hash:hash_alg,o_aead:aead_alg,
  i_g:group,i_domain:domain,i_hash:hash_alg,i_aead:aead_alg,
  ech_config:ECHConfig
  ) =

  (* Compute the client hello *)
  let client_hello = mk_encrypted_client_hello(o_g,o_domain,o_hash,o_aead,i_g,i_domain,i_has,i_aead,ech_config) in
  out(io,client_hello);
  0.

(* The ECH server should behave differently depending on the client hello
  message received and in particular what is the ECHO extension:
    - If none then behave as a normal handshake.
    - If ech_is_inner then the server acts as a backend server
    - If encrypted_client_hello then the server acts as a client-facing server

  The server takes as argument an ech_config and the secret key associated the public
  key contained in the ECHConfig.

  Question: Is there a ECHConfig Server data structure ? I did not find it in the RFC.
*)
let ECH_server(ech_config:ECHConfig,skR:element) =

  in(io,CH(r,offer));
  let nego(=TLS13,DHE_13(g,gx),hash_alg,aead_alg,sni_ext,ech_ext,pre_shared_key) = offer in

  if ech_ext = none_ECHExt
  then StandardServer(offer)
  else if ech_ext = ech_is_inner
  then ECH_Backend_Server(offer)
  else ECH_Client_Facing_Server(ech_config,skR,offer).
