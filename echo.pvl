free io:channel.
free att_choice:channel.
const zero: bitstring.

(* For now the communication between client-facing server and backend server
  will be done on a single private channel. Using multiple channels, though
  closer to reality would makes it difficult to prove equivalence properties. *)
free srv_ch:channel [private].

(********************************************************)
(* Generation of random                                 *)
(********************************************************)

type bytes24.
type bytes8.

type bytes32.

const zero8:bytes8.
fun B32(bytes24,bytes8):bytes32 [data].

letfun gen_B32_random() =
  new rand24:bytes24;
  new rand8:bytes8;
  B32(rand24,rand8).

(* QUESTION : I don't like putting the crop function as a one-way function
  but i don't think we could put it with option [data] otherwhise the attacker
  would trivally understand whether the byte8 corresponds to an accept message
  or to a random. *)
fun crop_into_bytes8(bitstring):bytes8.

(********************************************************)
(* Authenticated Encryption with Additional Data *)
(* extended with with weak/strong algorithms: See Lucky13, Beast, RC4 *)
(********************************************************)

(* Aead algorithm. Abstracted into whether we consider strong or weak security
    guarantees. *)
type aead_alg.
const WeakAE, StrongAE: aead_alg.

type aead_key.
fun b2ae(bitstring):aead_key [typeConverter].

fun aead_enc(aead_alg, aead_key, bitstring, bitstring, bitstring): bitstring.
fun aead_forged(bitstring,bitstring): bitstring.

fun aead_dec(aead_alg, aead_key, bitstring, bitstring, bitstring): bitstring
reduc forall a:aead_alg, k:aead_key, n,p,ad:bitstring;
  aead_dec(a, k, n, ad, aead_enc(a, k, n, ad, p)) = p
otherwise forall a:aead_alg, k:aead_key, n,p,p',ad,ad':bitstring;
  aead_dec(WeakAE, k, n, ad, aead_forged(p,aead_enc(WeakAE, k, n, ad', p'))) = p.

fun aead_leak(bitstring):bitstring
reduc forall k:aead_key, n,ad,x:bitstring;
  aead_leak(aead_enc(WeakAE,k,n,ad,x)) = x.

(********************************************************)
(* Diffie-Hellman, modeled as a KEM *)
(* Include a small/bad subgroup attacks. *)
(********************************************************)

type group.
const WeakDH: group [data].
const StrongDH: group [data].

type element.
const guessable: element.
fun e2b(element): bitstring [typeConverter] (* TODO: e2b could be a type convertor ? *).

(* Key Generation *)
fun dh_pub(group,bitstring): element.

fun discrete_log(element): bitstring
reduc forall x:bitstring;
  discrete_log(dh_pub(WeakDH,x)) = x.

letfun dh_keygen(g:group) =
  new x:bitstring;
  let gx = dh_pub(g,x) in
  (x,gx).

(* Encap/Decap Functionality *)
fun dh_encap_fun(group,element,element):element.
fun dh_decap_fun(group,element,bitstring): element
reduc forall g:group, x:bitstring, gxy:element;
  dh_decap_fun(g,dh_encap_fun(g,dh_pub(g,x),gxy),x) = gxy.

(* Generate then Encap *)
letfun dh_encap(g:group,gx:element) =
  new gxy:element;
  (gxy, dh_encap_fun(g,gx,gxy)).

(* Decap: never fails *)
letfun dh_decap(g:group,gy:element,x:bitstring) =
  let gxy = dh_decap_fun(g,gy,x) in
    gxy
  else (
    new gxy:element;
    gxy).

(**************************************************************)
(* Hash Functions, including those with collisions. See SLOTH *)
(**************************************************************)

type hash_alg.
const StrongHash: hash_alg [data].
const WeakHash: hash_alg [data].

const collision:bitstring [data].
fun hash_ideal(bitstring):bitstring.

fun hash(hash_alg,bitstring): bitstring
reduc forall x:bitstring;
      hash(WeakHash,x) = collision
otherwise forall x:bitstring;
      hash(StrongHash,x) = hash_ideal(x).

(********************************************************)
(* HMAC *)
(********************************************************)

type mac_key.
fun b2mk(bitstring):mac_key [typeConverter].

fun hmac_ideal(mac_key,bitstring): bitstring.

fun hmac(hash_alg,mac_key,bitstring):bitstring
reduc forall k:mac_key, x:bitstring;
  hmac(WeakHash,k, x) = collision
otherwise forall x:bitstring, k:mac_key;
  hmac(StrongHash,k, x) = hmac_ideal(k,x).

(********************************************************)
(* Public Key Signatures *)
(********************************************************)

type privkey.
type pubkey.
fun pk(privkey): pubkey.
const NoPubKey:pubkey.

(* RSA Signatures, typically the argument is a hash over some data *)

fun sign(privkey,bitstring):bitstring.
fun verify(pubkey,bitstring,bitstring): bool
reduc forall k:privkey, x:bitstring;
      verify(pk(k),x,sign(k,x)) = true.

(********************************************************)
(* Public Key Encryption with decryption and signing oracle *)
(* for weak decrytion algorithsm (PKCS1). See DROWN/Bleichenbacher *)
(********************************************************)

type rsa_alg.
const WeakRSAKey: privkey.
const WeakRSADecryption, StrongRSADecryption:rsa_alg.

fun rsa_enc(pubkey,bitstring): bitstring.

type result.
fun success(bitstring,bitstring):result [data].
fun failure(bitstring):result [data].

fun rsa_dec(rsa_alg,privkey,bitstring): result
reduc forall k:privkey, x:bitstring;
      rsa_dec(StrongRSADecryption,k,rsa_enc(pk(k),x)) = success(x,zero)
otherwise forall k:privkey, x:bitstring;
      rsa_dec(WeakRSADecryption,k,rsa_enc(pk(k),x)) = success(x,(x,sign(k,x))).


(********************************************************)
(* Long term keys *)
(********************************************************)

type prin.
fun prin2b(prin):bitstring [data].
table longTermKeys(prin,privkey,pubkey).
table esniKeys(prin,group,bitstring,element).
table ticketEncryptionKeys(prin,aead_key).

type preSharedKey.
const NoPSK: preSharedKey.
fun PSK(bitstring): preSharedKey [data].
fun psk2b(preSharedKey): bitstring
reduc forall b:bitstring; psk2b(PSK(b)) = b
otherwise psk2b(NoPSK) = zero.

table preSharedKeys(prin,prin,bitstring,preSharedKey).

(********************************************************)
(* HKDF *)
(********************************************************)

type label.

(* Labels of ECHO *)
const info_hash_lbl,secret_lbl,key_lbl,base_nonce_lbl,exp_lbl: label.

const ech_accept_confirmation:label.

(* Labels of TLS *)
const tls13_client_handshake_traffic_secret,
      tls13_server_handshake_traffic_secret,
      tls13_client_early_traffic_secret,
      tls13_client_application_traffic_secret,
      tls13_server_application_traffic_secret,
      tls13_key, tls13_iv,
      tls13_early_exporter_master_secret,
      tls13_exporter_master_secret,
      tls13_resumption_master_secret,
      tls13_resumption_psk_binder_key,
      tls13_finished,tls13_derived,tls13_esni_key,tls13_esni_iv: label.

letfun prf(k:bitstring,x:bitstring) =
  hmac(StrongHash,b2mk(k),x).

letfun hkdf_extract(s:bitstring,k:bitstring) =
  prf(s,k).

letfun hkdf_expand_label(k:bitstring,l:label,h:bitstring) =
  prf(k,(l,h)).

(** Key Schedule. TLS 1.3 RFC Section 7.1 *)

letfun derive_secret(k:bitstring,l:label,m:bitstring) =
  hkdf_expand_label(k,l,hash(StrongHash,m)).

(* Function to generate "Early Secret" + binder_key
 *)
letfun kdf_es(psk:preSharedKey) =
  let early_secret = hkdf_extract(zero,psk2b(psk)) in
  let binder_key = derive_secret(early_secret,tls13_resumption_psk_binder_key,zero) in
  (early_secret,b2mk(binder_key)).

letfun kdf_k0(early_secret:bitstring,client_hello:bitstring) =
  (* client_early_traffic_secret *)
  let atsc0 = derive_secret(early_secret,tls13_client_early_traffic_secret,client_hello) in

  (* QUESTION: What is kc0 ? Is it the Traffic Key Calculation (Section 7.3 in TLS RFC) *)
  let kc0   = hkdf_expand_label(atsc0,tls13_key,zero) in

  (* early_exporter_master_secret*)
  let ems0   = derive_secret(early_secret,tls13_early_exporter_master_secret,client_hello) in

  (b2ae(kc0),ems0).

(* Function to generate Handshake Secret. *)
letfun kdf_hs(early_secret:bitstring,e:element) =
  let extra = derive_secret(early_secret,tls13_derived,hash(StrongHash,zero)) in
  hkdf_extract(extra,e2b(e)).

(* Function to generate
  - Master Secret
  - client_handshake_traffic_secret
  - server_handshake_traffic_secret
  - client_write_key for handshake record (Section 7.3 of TLS RFC)
  - server_write_key for handshake record  (Section 7.3 of TLS RFC)
  - client_finished_key (Section 4.4.4 of TLS RFC)
  - server_finished_key (Section 4.4.4 of TLS RFC)
  The log should contain the client_hello and the server hello. *)
letfun kdf_ms(handshake_secret:bitstring,log:bitstring) =
  let extra = derive_secret(handshake_secret,tls13_derived,hash(StrongHash,zero)) in
  let master_secret = hkdf_extract(handshake_secret, zero) in
  let client_hts = derive_secret(handshake_secret, tls13_client_handshake_traffic_secret, log) in
  let server_hts = derive_secret(handshake_secret, tls13_server_handshake_traffic_secret, log) in

  (* [sender]_write_key for handshake record *)
  let client_wkh =  hkdf_expand_label(client_hts,tls13_key,zero) in
  let server_wkh =  hkdf_expand_label(server_hts,tls13_key,zero) in

  (* [sender]_finished_key *)
  let client_fk =  hkdf_expand_label(client_hts,tls13_finished,zero) in
  let server_fk =  hkdf_expand_label(server_hts,tls13_finished,zero) in
  (master_secret,b2ae(client_wkh),b2ae(server_wkh),b2mk(client_fk),b2mk(server_fk)).

(* Function to generate:
  - client_write_key for Application Data record
  - server_write_key for Application Data record
  - exporter_master_secret
  The log must contain ClientHello up to server Finished.
  *)
letfun kdf_k(master_secret:bitstring,log:bitstring) =
  let client_ats = derive_secret(master_secret, tls13_client_application_traffic_secret, log) in
  let server_ats = derive_secret(master_secret, tls13_server_application_traffic_secret, log) in

  let ems	= derive_secret(master_secret, tls13_exporter_master_secret, log) in

  let client_wkad = hkdf_expand_label(client_ats,tls13_key,zero) in
  let server_wkad = hkdf_expand_label(server_ats,tls13_key,zero) in

  (b2ae(client_wkad),b2ae(server_wkad),ems).

(* Function to generate resumption_master_secret. The log must contain:
  ClientHello up to client Finished. *)
letfun kdf_psk(master_secret:bitstring, log:bitstring) =
  derive_secret(master_secret,tls13_resumption_master_secret,log).

(********************************************************)
(* HPKE *)
(********************************************************)

(* Vincent : I'm trying to match a bit more closely the RFC for now compared
   to the equation provided.*)

(* We consider here the HPKE without pre shared key so the functions are
   simplified to remove all references to pre shared key. *)

type HpkeMode.
const R,S:HpkeMode.

type HpkeContext.
fun hpke_context(HpkeMode,aead_key,bitstring,bitstring):HpkeContext [data].

const nonce_for_seal_open:bitstring. (* Temporary until I understant how to model
  the nonce that are generated from the internal sequence *)

letfun kpke_seal(context:HpkeContext,aad:bitstring,pt:bitstring) =
  let hpke_context(=S,key,nonce,exporter) = context in
  aead_enc(StrongAE,key,nonce_for_seal_open,aad,pt).

letfun hpke_open(context:HpkeContext,aad:bitstring,ct:bitstring) =
  let hpke_context(=R,key,nonce,exporter) = context in
  aead_dec(StrongAE,key,nonce_for_seal_open,aad,ct).


letfun hpke_key_schedule(m:HpkeMode,shared_secret:element,info:bitstring) =
  let info_hash = hkdf_extract(zero,(info_hash_lbl,info)) in
  let xsecret = hkdf_extract(e2b(shared_secret),(secret_lbl,zero)) in

  let key = b2ae(hkdf_expand_label(xsecret,key_lbl,info_hash)) in
  let base_nonce = hkdf_expand_label(xsecret,base_nonce_lbl,info_hash) in
  let exporter_secret = hkdf_expand_label(xsecret,exp_lbl,info_hash) in

  hpke_context(m,key,base_nonce,exporter_secret).

(* SetupBaseS and SetupBaseR (5.1.1 in RFC HPKE )*)

letfun hpke_setup_base_S(pkR:element,info:bitstring) =
  let (shared_secret:element,enc:element) = dh_encap(StrongDH,pkR) in
  (enc,hpke_key_schedule(S,shared_secret,info)).

letfun hpke_setup_base_R(enc:element,skR:element,info:bitstring) =
  let shared_secret:element = dh_decap(StrongDH,enc,e2b(skR)) in
  hpke_key_schedule(R,shared_secret,info).

(***************************************
  The Encrypted Client Hello functions
****************************************)

(*******************************)
(* Echo Configuration          *)

(* Data structure of ECHCipherSuite:
    We consider all elements of [ECHCipherSuite] of the RFC (Section 4.):
      - kdf_id of type [HpkeKdfId] in RFC
      - aead_id of type [AeadId] in RFC
    "Corresponds to the list of HPKE KDF and AEAD identifier pairs clients
      can use for encrypting ClientHelloInner."
*)

(* TODO : For now, ProVerif does not allow the syntax
  type AeadId = ae_alg.
  I would like to push for it but for now I comment the part and replace it with
  something that ProVerif accepts *)

type HpkeKdfId.
(*type AeadId = ae_alg.*)
type HpkeSymmetricCipherSuite.
fun hpke_symmetric_cipher_suite(HpkeKdfId, aead_alg (* AeadId *) ):HpkeSymmetricCipherSuite [data].

(* Data structure of HpkeKeyConfig
    We consider all elements of [HpkeKeyConfig] of the RFC (Section 4.):
      - config_id of type [uint8] in RFC ([nat] in this model)
      - kem_id of type [HpkeKemId] in RFC
      - public_key of type [HpkePublicKey] in RFC (which is an alias of [element] in this model)
      - cipher_suites of type [HpkeSymmetricCipherSuite] in RFC
*)

type domain.
type HpkeKemId.
(* type HpkePublicKey = element. *)
type HpkeKeyConfig.
fun hpke_key_config(nat,HpkeKemId, element (* HpkePublicKey *) ,HpkeSymmetricCipherSuite):HpkeKeyConfig [data].

(* Data structure of ECHConfigContents (Section 4 of ECH RFC)
    We only consider the following elements:
      - key_config of type [HpkeKeyConfig]
      - public_name of type [opaque] in RFC ([domain] in this model)
*)

type ECHConfigContents.
fun ECH_config_contents(HpkeKeyConfig,domain):ECHConfigContents [data].

(* Data structure of ECHConfig (Section 4 of ECH RFC)
    We consider the following elements:
      - version of type [uint16] in RFC ([ECH_version] in this model. Could be aliased
        by natural number maybe ?)
      - We consider a single ECHConfigContents
*)

type ECH_version.
type ECHConfig.
fun ECH_config(ECH_version,ECHConfigContents):ECHConfig [data].

(* Some useful access functions *)
letfun get_public_key(ech_config:ECHConfig) =
  let ECH_config(v,ECH_config_contents(hpke_key_config(config_id,kemid,public_key,ciphersuite),dom)) = ech_config in
  public_key.

letfun get_hpke_cipher_suite(ech_config:ECHConfig) =
  let ECH_config(v,ECH_config_contents(hpke_key_config(config_id,kemid,public_key,ciphersuite),dom)) = ech_config in
  ciphersuite.

letfun get_config_id(ech_config:ECHConfig) =
  let ECH_config(v,ECH_config_contents(hpke_key_config(config_id,kemid,public_key,ciphersuite),dom)) = ech_config in
  config_id.

(*****************************************************)
(* The "encrypted_client_hello" Extension. Section 5 *)

type EncryptedClientHelloExt.

(* Represents the absence of extension *)
const none_ECHExt: EncryptedClientHelloExt.

(* This extension should only occur in the ClientHelloInner. *)
const ech_is_inner: EncryptedClientHelloExt.

(* This extension should only occur in the ClientHelloOuter. *)
(* This includes the following element
    - cipher_suite of type [HpkeSymmetricCipherSuite];
    - config_id of type [uint8] in RFC ([nat] in this model). Should be the same
      as in the ECH config.
    - enc of type [opaque] in RFC ([element] in this model). It's the The HPKE encapsulated key
    - payload of type [opaque] in RFC ([bitstring] in this model).
*)
fun client_ECH(HpkeSymmetricCipherSuite,nat,element,bitstring): EncryptedClientHelloExt [data].

(***************************************
  TLS message formats
****************************************)

type TLS_version.
const TLS12, TLS13: TLS_version.

(* COMMENT Vincent: We keep for now almost the same structure as the original
  file to reuse as much as possible but it would be nicer if we get as close as
  possible from the RFC

Example of possible new data representation:

type ClientHello.
fun client_hello(TLS_version,random,CipherSuite,SniExt,EncryptedClientHelloExt,PreSharedKeyExt):ClientHello

We would use that rather than the current function nego.
*)

type kex_alg.
fun DHE_13(group,element): kex_alg [data].

(* The SNI extension *)

type sni.
fun SNI(domain): sni [data]. (* QUESTION : Would the argument of SNI be
  considered as an element of type domain ? *)

(* The Pre Shared Key extension *)
type psk_type.
fun Binder(bitstring): psk_type [data].
fun NoBinder(): psk_type [data].

(* The function negotiation is extended to contain the ECHO extension *)

type params.
fun nego(TLS_version,kex_alg,hash_alg,aead_alg,sni,EncryptedClientHelloExt,psk_type): params [data].

type msg.
fun msg2bitstring(msg):bitstring [typeConverter].
fun CH(bytes32,params):msg [data].
fun SH(bytes32,params):msg [data].
fun CRT(domain,pubkey):msg [data].
fun CV(bitstring):msg [data].
fun FIN(bitstring):msg [data].

table clientSession(bytes32,bytes32,preSharedKey,pubkey,
		    params,params,
		    aead_key,aead_key,bitstring,bitstring).
table serverSession(bytes32,bytes32,preSharedKey,pubkey,
		    params,params,
		    aead_key,aead_key,bitstring,bitstring).

(*****************************************************)
(* Authenticating the ClientHelloOuter. Section 5.1 *)

(* TODO: Some sentence that I'm not sure to understand yet :
  "passing it in as the associated data for HPKE sealing and opening
   operations."
*)

type ClientHelloOuterAAD.
fun ChoAAD2bitstring(ClientHelloOuterAAD):bitstring [typeConverter].
fun client_hello_outer_AAD(HpkeSymmetricCipherSuite,nat,element,msg):ClientHelloOuterAAD [data].


letfun mk_client_hello_outer_AAD(client_hello_outer:msg) =
  let CH(r,nego(version,k_alg,h_alg,ae_alg,xsni,echo,psk)) = client_hello_outer in
  let client_ECH(cipher_suite,config_id,enc,payload) = echo in

  (* The client_hello_outer with extension removed *)
  let client_hello_outer' = CH(r,nego(version,k_alg,h_alg,ae_alg,xsni,none_ECHExt,psk)) in

  client_hello_outer_AAD(cipher_suite,config_id,enc,client_hello_outer').

(********************************************
  The Client side of ECHO (Section 6 of RFC)
*********************************************)

const tls_ech_str:bitstring.

letfun mk_encrypted_client_hello(
  o_g:group,o_domain:domain,o_hash:hash_alg,o_aead:aead_alg,
  i_g:group,i_domain:domain,i_hash:hash_alg,i_aead:aead_alg,
  ech_config:ECHConfig
  ) =
  (* Vincent : I think some of the arguments should be contained within the ECHConfig
    and/or check that they correspond to the ech_config given as argument. Most probably:
      - o_domain
      - i_domain
      - o_aead and i_aead used in TLS should probably also match the one in ECHConfig.
  *)

  (* Retrieve the pre-shared key *)
  (* TODO : Shouldn't the preshared key be parametrised in the table by the user / server ?
    Question : From what I understood, the model A and SN represents the client and the server.
    However, I don't see where in the model where they are used.*)
  get preSharedKeys(id_client,srv_name,tkt,psk) in


  (* Client Hello Inner *)
  let (i_x:bitstring,i_gx:element) = dh_keygen(i_g) in
  let (early_secret:bitstring,kb:mac_key) = kdf_es(psk) in (* For Pre Shared Keys *)
  let i_r = gen_B32_random() in
  let i_offer1 = nego(TLS13,DHE_13(i_g,i_gx),i_hash,i_aead,SNI(i_domain),ech_is_inner,Binder(zero)) in
  let preshared_ext = Binder(hmac(StrongHash,kb,msg2bitstring(CH(i_r,i_offer1)))) in
  let i_offer2 = nego(TLS13,DHE_13(i_g,i_gx),i_hash,i_aead,SNI(i_domain),ech_is_inner,preshared_ext) in
  let i_client_hello = CH(i_r,i_offer2) in

  (* TODO : The Encoded Client Hello Inner is not done yet. Need to understand what to do *)

  (* Generation of the Client Hello Outer with a dummy ECHO extension *)
  let (o_x:bitstring,o_gx:element) = dh_keygen(o_g) in
  let o_r = gen_B32_random() in
  let o_offer1 = nego(TLS13,DHE_13(o_g,o_gx),o_hash,o_aead,SNI(o_domain),none_ECHExt,Binder(zero)) in
  let o_client_hello1 = CH(o_r,o_offer1) in

  let client_hello_AAD = mk_client_hello_outer_AAD(o_client_hello1) in

  (* Generating the HPKE Context (Section 6.1 in RFC)*)
  let pkR = get_public_key(ech_config) in
  let (enc:element,context:HpkeContext) = hpke_setup_base_S(pkR,(tls_ech_str,ech_config)) in
  let payload = kpke_seal(context,ChoAAD2bitstring(client_hello_AAD),msg2bitstring(i_client_hello)) in

  let cipher_suite = get_hpke_cipher_suite(ech_config) in
  let config_id = get_config_id(ech_config) in

  let ech_ext = client_ECH(cipher_suite,config_id,enc,payload) in

  (* We plug the Echo extension in the ClientHelloOuter to generate the final client hello message.
      Question : Unless i'm mistaken, i need to use the same random, hash id, etc as the ones used in
      to generate the client hello AAD.
   *)
  let offer = nego(TLS13,DHE_13(o_g,o_gx),o_hash,o_aead,SNI(o_domain),ech_ext,Binder(zero)) in
  (CH(o_r,offer),i_client_hello,i_x,o_x,early_secret).

(*****************************************************
  The Client-Facing Server in ECHO (Section 7.1 of RFC)
******************************************************)

let ECH_Client_Facing_Server(ech_config:ECHConfig,skR:element,client_hello_outer:msg) =

  (* Verify that the ECH_config corresponds to the client hello message and that
    the decryption works.
    If the verification does not match then the server should continue the
    connection with the ClientHelloOuter. In RFC it is added that:
      This connection proceeds as usual, except the server MUST include the
      "encrypted_client_hello" extension in its EncryptedExtensions with
      the "retry_configs" field set to one or more ECHConfig structures
      with up-to-date keys.
  *)
  let config_id = get_config_id(ech_config) in
  let cipher_suite = get_hpke_cipher_suite(ech_config) in

  let CH(r,offer) = client_hello_outer in
  let nego(=TLS13,DHE_13(g,gx),h_alg,a_alg,sni_ext,ech_ext,pre_shared_key) = offer in
    let client_ECH(=cipher_suite,=config_id,enc,payload) = ech_ext in
    (

      let client_hello_AAD = mk_client_hello_outer_AAD(client_hello_outer) in
      let context = hpke_setup_base_R(enc,skR,(tls_ech_str,ech_config)) in

      let ch_inner = hpke_open(context,ChoAAD2bitstring(client_hello_AAD),payload) in
        (* The verification succeed hence the server must forward the message to
           the backend server.

           Question : Is the forwarding done on a public channel ? private channel ?
           If it's on a public channel, should we consider that the attacker will do
           the forwarding itself if he wants to so we don't need to write anything
           anymore.

           Answer : Should be sent on a private channel to the backend (currently).
        *)
        out(srv_ch,ch_inner);
        (* After that the server forwards messages between client and backend server
          The modeling is quite generic. Will be restricted if necessary for proofs. *)
        (! in(srv_ch,x:bitstring); out(io,x)) |
        (! in(io,x:bitstring); out(srv_ch,x))
      else
        (* The decryption failed. According to the Echo RFC, the server must ignore
        the extension and proceed as usual with ClientHellOuter, "except the server
        MUST include the "encrypted_client_hello" extension in its EncryptedExtensions
        with the "retry_configs" field set to one or more ECHConfig structures
        with up-to-date keys"
        *)
        0
    )
    else 0
  else 0
  .

(****************************************************************************
  The Standard TLS Server or the Backend Server in ECHO (Section 7.2 of RFC)
*****************************************************************************)

(* A backend-server plays the same role as a standard server with two key-distinctions:
  - Check that the ECHO extension is "ech_is_inner".
  - Compute an accept_confirmation message
*)

let Standard_or_Backend_Server(is_std:bool,client_hello:msg) =
  let CH(cr,offer) = client_hello in
  let nego(=TLS13,DHE_13(g,gx),h_alg,a_alg,SNI(dom),ech_ext,Binder(m)) = offer in

  (* Checking the ECHO extension *)
  if (none_ECHExt = ech_ext && is_std) || (ech_is_inner = ech_ext && not(is_std)) then

  (* QUESTION : Identification of the server.
    I believe that the SNI could play the "identifier" that determines which keys
    to retrieve and check, etc *)

  (* Retreive the pre_shared_keys *)
  (* QUESTION: I'm very much confused with the way preSharedKeys are modeled in the
    tls model. I will stick to the TLS code for now but an explanation would be
    much needed.*)
  get preSharedKeys(a,sn,tkt,psk) in

  let (early_secret:bitstring,kb:mac_key) = kdf_es(psk) in
  let zoffer = nego(TLS13,DHE_13(g,gx),h_alg,a_alg,SNI(dom),ech_ext,Binder(zero)) in
  if m = hmac(StrongHash,kb,msg2bitstring(CH(cr,zoffer))) then
  let (kc0:aead_key,ems0:bitstring) = kdf_k0(early_secret,msg2bitstring(client_hello)) in

  (* The serveur must choose the configuration from the set of cipher suite
  provided by the client. In the previous TLS model, the attacker were choosing
  the configuration. For equivalence properties, we may want to also have an honest
  server in the mix in case it is too strong to always let the attacker choose.

  Question : why in original TLS model, the group is not chosen by the attcker ? *)

  in(att_choice,(mode:params));
  let nego(=TLS13,DHE_13(=g,gx_srv),h_alg_srv,a_alg_srv,sni_srv,=none_ECHExt,pre_shared_key) = mode in

  let (gxy:element,gy:element) = dh_encap(g,gx) in

  let handshake_secret = kdf_hs(early_secret,gxy) in

  let srv_offer = nego(TLS13,DHE_13(g,gy),h_alg_srv,a_alg_srv,sni_srv,none_ECHExt,pre_shared_key) in
  let sr =
    if is_std
    then gen_B32_random()
    else
      (* Generate the accept confirmation when the it's a backend server. *)
      new sr24:bytes24;
      let SH_ECHConf = SH(B32(sr24,zero8),srv_offer) in
      let accept_confirmation = derive_secret(handshake_secret,ech_accept_confirmation,(client_hello,SH_ECHConf)) in
      let sr8 = crop_into_bytes8(accept_confirmation) in
      B32(sr24,sr8)
  in
  let server_hello = SH(sr,srv_offer) in

  out(io,server_hello);

  (* We record all the messages exchanged *)
  let log_1 = (client_hello,server_hello) in

  (* TO CHECK. Should we ask srv_name to be equal to dom that is included in the SNI ?*)
  get longTermKeys(srv_name,srv_secret_key,srv_public_key) in

  let (master_secret:bitstring,chk:aead_key,shk:aead_key,cfin:mac_key,sfin:mac_key) =
      kdf_ms(handshake_secret,log_1) in

  (* The server should now ouput
    - EncryptedExtensions (Not in the current model)
    - CertificateRequest (Not in the current model)
    - Certificate (In the current model with long term keys)
    - CertificateVerify
    - Finished
    All of them should be protected with the write key derived from server_handshake_traffic_secret,
    i.e. shk.
  *)
  (* The Certificate message *)
  (* QUESTION : Why here we use by default StrongAE but that does not match with
    the server offer, i.s. a_alg_srv *)
  let certificate_msg = CRT(dom,srv_public_key) in
  let encrypted_certificate_msg = aead_enc(StrongAE,shk,zero,zero,msg2bitstring(certificate_msg)) in
  out(io,encrypted_certificate_msg);

  (* The CertificateVerify message *)
  (* QUESTION : Why is the CertificateVerify and Finished message in tls-lib are not encrypted ?
  From the TLS RFC page 10, it seems to me that they should be encrypted like the certificate message.
  It's not done in tls-lib.pvl *)
  (* QUESTION : I'm not sure whether the log should contain the messages or the encrypted message.
  From the TLS RFC and the model, I have the impression that it should be the non-encrypted version
  but I would like to be sure. *)
  let log_2 = (log_1,certificate_msg) in
  let signed_log = sign(srv_secret_key,hash(h_alg_srv,log_2)) in
  let certificate_verify_msg = CV(signed_log) in
  let encrypted_certificate_verify_msg = aead_enc(StrongAE,shk,zero,zero,msg2bitstring(certificate_verify_msg)) in
  out(io,encrypted_certificate_verify_msg);

  (* The Finished message *)
  (* QUESTION : Similar question here with respect to StrongHash. Why is it not h_alg_srv (as it is
  the case for the signature of the log ?) *)
  let log_3 = (log_2,certificate_verify_msg) in
  let finished_msg = FIN(hmac(StrongHash,sfin,log_3)) in
  let encrypted_finished_msg = aead_enc(StrongAE,shk,zero,zero,msg2bitstring(finished_msg)) in
  out(io,encrypted_finished_msg);

  (* The server should now wait from the client the following:
    - Certificate (Not in the current model)
    - CertificateVerify (Not in the current model)
    - Finished
  *)
  in(io,enc_client_finished:bitstring);
  let log_4 = (log_3,finished_msg) in
  let (cak:aead_key,sak:aead_key,ems:bitstring) = kdf_k(master_secret,log_4) in

  let msg2bitstring(client_finished_msg) = aead_dec(StrongAE,chk,zero,zero,enc_client_finished) in
  let FIN(hash_msg) = client_finished_msg in

  if hash_msg = hmac(StrongHash,cfin,log_4)
  then
    let log_5 = (log_4,client_finished_msg) in
    let rms = kdf_psk(master_secret,log_5) in

    insert serverSession(cr,sr,psk,srv_public_key,offer,mode,cak,sak,ems,rms)
  else 0
  .

(****************************************************************************
  The Standard TLS Client connection after dealing with ECH
*****************************************************************************)

let Standard_Client(
  dom:domain,h_alg:hash_alg,a_alg:aead_alg,
  psk:preSharedKey, handshake_secret:bitstring,
  client_hello:msg,server_hello:msg
  ) =
  let CH(cr,offer) = client_hello in
  let SH(sr,mode) = server_hello in

  let log_1 = (client_hello,server_hello) in
  let (master_secret:bitstring,chk:aead_key,shk:aead_key,cfin:mac_key,sfin:mac_key) =
    kdf_ms(handshake_secret,log_1)
  in

  (* Process the Certificate message *)
  in(io,enc_crt_msg:bitstring);
  let msg2bitstring(certificate_msg) = aead_dec(StrongAE,shk,zero,zero,enc_crt_msg) in
  (* QUESTION: Usual question about the host name *)
  let CRT(hn,srv_public_key) = certificate_msg in
  let log_2 = (log_1,certificate_msg) in

  (* QUESTION : In the model tls-lib.pvl, the client access the table longTermKeys
  and checks whether the public key is in the table. Should i understand that this
  corresponds to checking that the certificate for the public key is valid ? *)
  (* QUESTION: Usual question about the server name. *)
  get longTermKeys(srv_name,srv_secret_key,=srv_public_key) in

  (* Process the Certificate Verify message *)
  in(io,enc_crt_verif_msg:bitstring);
  let msg2bitstring(certificate_verify_msg) = aead_dec(StrongAE,shk,zero,zero,enc_crt_verif_msg) in
  let CV(signed_log) = certificate_verify_msg in
  if verify(srv_public_key,hash(h_alg,log_2),signed_log) then
  let log_3 = (log_2,certificate_verify_msg) in

  (* Process the Finished message *)
  in(io,enc_finished_msg:bitstring);
  let msg2bitstring(finished_msg) = aead_dec(StrongAE,shk,zero,zero,enc_finished_msg) in
  let FIN(hash_msg) = finished_msg in
  if hash_msg = hmac(StrongHash,sfin,log_3) then
  let log_4 = (log_3,finished_msg) in

  (* Send the Client Finished message *)
  let (cak:aead_key,sak:aead_key,ems:bitstring) = kdf_k(master_secret,log_4) in
  let client_hash_msg = hmac(StrongHash,cfin,log_4) in
  let client_finished_msg = FIN(client_hash_msg) in

  let log_5 = (log_4,client_finished_msg) in
  let rms = kdf_psk(master_secret,log_5) in
  insert clientSession(cr,sr,psk,srv_public_key,offer,mode,cak,sak,ems,rms);

  let enc_client_finished_msg = aead_enc(StrongAE,chk,zero,zero,msg2bitstring(client_finished_msg)) in
  out(io,enc_client_finished_msg)
  .

(*****************************************************
  The main protocol
******************************************************)

let ECH_client(
  o_g:group,o_domain:domain,o_hash:hash_alg,o_aead:aead_alg,
  i_g:group,i_domain:domain,i_hash:hash_alg,i_aead:aead_alg,
  ech_config:ECHConfig
  ) =
  (* QUESTION: Can ge group for inner and outer be different ? *)

  (* Compute the client hello *)
  let (o_client_hello:msg,i_client_hello:msg,i_x:bitstring,o_x:bitstring,i_psk:preSharedKey,i_early_secret:bitstring) = mk_encrypted_client_hello(o_g,o_domain,o_hash,o_aead,i_g,i_domain,i_hash,i_aead,ech_config) in
  out(io,o_client_hello);

  (* Receive the answer from the server *)
  in(io,server_hello:msg);

  (* QUESTION: In the tls-lib.pvl, a clientSession0 is inserted. Need to see
  what we will do with it since may need to insert it after knowing if the server
  accepted the ECH or not. *)

  let SH(B32(sr24,sr8),mode) = server_hello in
  (
    let nego(=TLS13,DHE_13(g_srv,gy_srv),h_srv,a_srv,sni_srv,ech_ext,presharedkey_srv) = mode in

    if g_srv = i_g
    then (
      (* Compute the handshake secret *)
      let i_gxy = dh_decap(i_g,gy_srv,i_x) in
      let i_handshake_secret = kdf_hs(i_early_secret,i_gxy) in

      (* Determinaing whether ECH was accepted or not *)
      let is_accepted:bool =
        let SH_ECHConf = SH(B32(sr24,zero8),mode) in
        let accept_confirmation = derive_secret(i_handshake_secret,ech_accept_confirmation,(i_client_hello,SH_ECHConf)) in
        sr8 = crop_into_bytes8(accept_confirmation)
      in

      if is_accepted
      then
        (* Proceeds with the connection as usual *)
        Standard_Client(i_domain,h_srv,a_srv,i_psk,i_handshake_secret,i_client_hello,server_hello)
      else
        (* Section 6.1.3.2 of ECHO RFC - Rejected ECH *)
        (* TODO *)
        0
      )
    else
      (* Section 6.1.3.2 of ECHO RFC - Rejected ECH *)
      (* TODO *)
      0
  )
  else
    (* Received something other than server hello *)
  0.

(* The ECH server should behave differently depending on the client hello
  message received and in particular what is the ECHO extension:
    - If none then behave as a normal handshake.
    - If ech_is_inner then the server acts as a backend server
    - If encrypted_client_hello then the server acts as a client-facing server

  The server takes as argument an ech_config and the secret key associated the public
  key contained in the ECHConfig.

  Question: Is there a ECHConfig Server data structure ? I did not find it in the RFC.
*)
let ECH_server(ech_config:ECHConfig,skR:element) =

  in(io,CH(r,offer));
  let nego(=TLS13,DHE_13(g,gx),h_alg,a_alg,sni_ext,ech_ext,pre_shared_key) = offer in

  if ech_ext = none_ECHExt
  then Standard_or_Backend_Server(true,CH(r,offer))
  else if ech_ext = ech_is_inner
  then Standard_or_Backend_Server(false,CH(r,offer))
  else ECH_Client_Facing_Server(ech_config,skR,CH(r,offer)).
