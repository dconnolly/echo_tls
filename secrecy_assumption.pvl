(* Secrecy assumption *)

(***** Key Schedule *****)

(*
  - prf(a,k,x): with a = id_hash(StrongHash,i)
      hmac_ideal(i,b2mk(k),x)

  - hkdf_extract(a,s,k) =
      hmac_ideal(i,b2mk(s),k)

  - hkdf_expand_label(a,k,l,h) =
      hmac_ideal(i,b2mk(k),(l,h))

  - derive_secret(a,k,l,m) =
      hmac_ideal(i,b2mk(k),(l,hash_ideal(i,m)))

  - kdf_es(h,PSK(psk)) =
      let early_secret = hmac_ideal(i,b2mk(zero),ipsk2b(psk)) in
      let binder_key =
        hmac_ideal(i,b2mk(early_secret),(tls13_resumption_psk_binder_key,hash_ideal(i,zero))) in

  - kdf_es(h,NoPSK) =
      let early_secret = hmac_ideal(i,b2mk(zero),zero) in
      let binder_key =
        hmac_ideal(i,b2mk(early_secret),(tls13_resumption_psk_binder_key,hash_ideal(i,zero))) in

  - kdf_hs(h,early_secret,e) =
      let extra_es = hmac_ideal(i,b2mk(early_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero))))
      let handshake_secret = hmac_ideal(i,b2mk(extra_es),e2b(e)) in

  - kdf_ms(h,handshake_secret,log) =
      let extra_hs = hmac_ideal(i,b2mk(handshake_secret),(tls13_derived,hash_ideal(i,hash_ideal(i,zero)))) in
      let master_secret = hmac_ideal(i,b2mk(handshake_secret),zero) in

      let client_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_client_handshake_traffic_secret,hash_ideal(i,log))) in
      let server_hts = hmac_ideal(i,b2mk(handshake_secret),(tls13_server_handshake_traffic_secret,hash_ideal(i,log))) in

      let client_wkh = hmac_ideal(i,b2mk(client_hts),(tls13_key,zero)) in
      let server_wkh = hmac_ideal(i,b2mk(server_hts),(tls13_key,zero)) in

      let client_fk = hmac_ideal(i,b2mk(client_hts),(tls13_finished,zero)) in
      let server_fk = hmac_ideal(i,b2mk(server_hts),(tls13_finished,zero)) in
*)

(***** DH keys *****)

(*
  - Honest keys are generated by the function dh_x(s)
  - Encapsulation are generated by the function dh_xy(s)
  - Failed decapsulation are generated by the function dh_f(s)
*)

(* Honest encapsulation will be :
    dh_encap_fun(id_g(StrongDH,i),dh_pub(id_g(StrongDH,i),dh_x(s)),dh_xy(s'))
*)

(* Decapsulation will be either :
    dh_xy(s) (when it is coming from an honest server)
    dh_f(s) (when the decapsultion failed)
    x (when the encapsulation was generated by an attacker)

    Scenario :
      - If Hon server and Hon client then dh_xy stays secret
      - If Hon server and Dis client then dh_xy is known by attacker
      - dh_f is always private as only generate by honest client.
*)

(***** Secrecy assumption ****)

(* Early secret :
    - Secret for non compromised psk

  Binder key :
    - Secret for non compromised psk

  Handshake secret :
    - Secret if either the early secret is secret or if the element is secret.

*)
