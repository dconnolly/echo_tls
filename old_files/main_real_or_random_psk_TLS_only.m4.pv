set removeEventsForLemma = true.

(* Restriction for equivalence *)

lemma c_dom,c_dom',s_dom,s_dom':domain,h_alg',h_alg:hash_alg,id,id':identityPsk,ipsk,ipsk':internal_preSharedKey,
  c_dom1,c_dom2,s_dom1,s_dom2:domain,h_alg1,h_alg2:hash_alg,id1,id2:identityPsk,ipsk1,ipsk2:internal_preSharedKey,
  safe,safe',safe1,safe2:bool,idP,idP',idP1,idP2:idProc;
  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk'],diff[idP,idP'],diff[safe,safe'])) ==>
    h_alg = id_hash(StrongHash,1) &&
    h_alg' = id_hash(StrongHash,1) &&
    id = mk_idpsk(c_dom,s_dom,h_alg,ipsk) &&
    id' = mk_idpsk(c_dom',s_dom',h_alg',ipsk') &&
    safe = safe' &&
    idP = idP';
  table(pre_shared_keys(diff[c_dom,c_dom1],diff[s_dom,s_dom1],diff[h_alg,h_alg1],diff[id,id1],diff[ipsk,ipsk1],idP,safe)) &&
  table(pre_shared_keys(diff[c_dom,c_dom2],diff[s_dom,s_dom2],diff[h_alg,h_alg2],diff[id,id2],diff[ipsk,ipsk2],idP',safe')) ==>
  c_dom1 = c_dom2 && s_dom1 = s_dom2 && h_alg1 = h_alg2 && id1 = id2 && ipsk1 = ipsk2 && safe = safe' && idP = idP';
  table(pre_shared_keys(diff[c_dom1,c_dom],diff[s_dom1,s_dom],diff[h_alg1,h_alg],diff[id1,id],diff[ipsk1,ipsk],idP,safe)) &&
  table(pre_shared_keys(diff[c_dom2,c_dom],diff[s_dom2,s_dom],diff[h_alg2,h_alg],diff[id2,id],diff[ipsk2,ipsk],idP',safe')) ==>
  c_dom1 = c_dom2 && s_dom1 = s_dom2 && h_alg1 = h_alg2 && id1 = id2 && ipsk1 = ipsk2 && safe = safe' && idP = idP';
  attacker(diff[ipsk,ipsk1]) &&  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk,ipsk2],idP,safe)) ==> ipsk1 = ipsk2 && safe <> true;
  attacker(diff[ipsk1,ipsk]) &&  table(pre_shared_keys(diff[c_dom,c_dom'],diff[s_dom,s_dom'],diff[h_alg,h_alg'],diff[id,id'],diff[ipsk2,ipsk],idP,safe)) ==> ipsk1 = ipsk2 && safe <> true
  [induction]
.

(* Dishonest key generation *)

let gen_dishonest_long_term_keys =
  !
  in(io,a:domain);
  event Same(d2b(a));
  new sk_d:privkey;
  out(io,(sk_d,valid_cert(a,pk(sk_d))))
.

let gen_dishonest_pre_shared_keys(h_alg:hash_alg) =
  !
  new idP:idProc;
  in(io,(c_dom:domain,s_dom:domain));
  event Same((c_dom,s_dom));
  new psk_d:internal_preSharedKey;
  let id = mk_idpsk(c_dom,s_dom,h_alg,psk_d) in
  insert pre_shared_keys(c_dom,s_dom,h_alg,id,psk_d,idP,false);
  out(io,psk_d)
.

process
  (* The group and cipher suite between TLS and Ech should be incompatible *)
  let tls_h = id_hash(StrongHash,1) in
  let tls_a = id_aead(StrongAE,1) in
  let tls_g = id_g(StrongDH,1) in
  let ech_h = id_hash(StrongHash,2) in
  let ech_a = id_aead(StrongAE,2) in
  let ech_g = id_g(StrongDH,2) in
  (
      main_process(tls_h,ech_h,tls_a,ech_a,tls_g,ech_g)
    | gen_dishonest_long_term_keys
    | gen_dishonest_pre_shared_keys(tls_h)
    | (
      !
      new id_client:idProc;
      in(io,use_psk:bool)[precise];
      in(io,send_kex:bool)[precise];
      in(io,(c_dom:domain,s_dom:domain,comp_psk:bool)) [precise];
      event Same((use_psk,send_kex,c_dom,s_dom,comp_psk));
      standard_client(id_client,comp_psk,use_psk,send_kex,c_dom,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    ) | (
      !
      in(io,use_psk:bool) [precise];
      in(io,cert_req:bool) [precise];
      in(io,s_dom:domain) [precise];
      event Same((use_psk,cert_req,s_dom));
      server(false,use_psk,cert_req,s_dom,tls_g,tls_h,tls_a,empty_extra_ext)
    )
  )

(* EXPECTPV FILENAME: ./main_real_or_random_psk_TLS_only.m4.pv TAG: 1
END *)
