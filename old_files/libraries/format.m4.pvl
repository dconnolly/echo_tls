changequote(<!,!>)dnl

channel io. (* The public channel *)

(* The type idProc represents process identifiers. Terms of this type are not
  used in the protocol itself. They are only used in proof helpers or in the
  lemmas, axioms and restrictions to talk specifically about a particular
  replicated process. *)
type idProc.
fun id2b(idProc):bitstring [typeConverter].

(* The type domain represents the public domain of the clients and servers.
  All terms of this type will be public. When we refer to a client or a server
  in our explanation, we always refer to their public domain. *)
type domain.
fun d2b(domain):bitstring [typeConverter].

(********************************************************)
(* Extra extension                                      *)
(********************************************************)

(* The type for some unspecified extra extension in the client hello. *)
type extraExt.
const empty_extra_ext:extraExt [data].

(********************************************************)
(* Key share Extension (4.2.8 in TLS RFC)               *)
(********************************************************)

(* A client can send only a group which will trigger and Hello Retry Request
  from the server, or a group and its key share. For Hello Retry Request, the
  extension consist only of a group. *)

type kex_alg.
fun DHE_group(group): kex_alg [data].
fun DHE_kex(group,element) : kex_alg [data].

type keyShareExt.
fun client_kex_ext(kex_alg): keyShareExt [data].
fun server_kex_ext(kex_alg): keyShareExt [data].
fun hrr_kex_ext(group): keyShareExt [data].

(********************************************************)
(* Pre Shared Keys Extension                            *)
(********************************************************)

type preSharedKey.

(* uc_psk is a private function used when generating uncompromised pre shared
  keys. Instead of using the classic syntax
    new psk:preSharedKey; ...
  we generate a seed and use the private function uc_psk.
    let psk = new s:seed; uc_psk(s) in ...
  This is equivalent but it allows us to more easily talk about keys when
  writing some proof helpers (see proof_helper.m4.pvl) and lemmas, axioms and
  restrictions. *)
fun uc_psk(seed):preSharedKey [private].
const NoPsk: preSharedKey.

fun b2psk(bitstring):preSharedKey [typeConverter].
fun psk2b(preSharedKey): bitstring
reduc
  psk2b(NoPsk) = zero
  otherwise forall x:preSharedKey; psk2b(x) = x
.

(* A type converter only used for some proof helpers. *)
fun psk2b_pf(preSharedKey):bitstring [typeConverter].

type identityPsk.
fun b2idpsk(bitstring):identityPsk [typeConverter].

(* The private function mk_idpsk is an abstraction on how the server is able to
  retrieve the pre shared key from its identity and additional information such
  as the ciphersuite used. By defining the function as private and its projections
  as private, we ensure that only the honest server can access its content.
  Note that it does not prevent the attacker to play the role of a server. *)
fun mk_idpsk(domain,domain,hash_alg,preSharedKey):identityPsk [private].

reduc forall c_dom,s_dom:domain, h_alg:hash_alg, psk:preSharedKey;
  get_sender_psk(mk_idpsk(c_dom,s_dom,h_alg,psk)) = c_dom [private].
reduc forall c_dom,s_dom:domain, h_alg:hash_alg, psk:preSharedKey;
  get_receiver_psk(mk_idpsk(c_dom,s_dom,h_alg,psk)) = s_dom [private].
reduc forall c_dom,s_dom:domain, h_alg:hash_alg, psk:preSharedKey;
  get_hash_psk(mk_idpsk(c_dom,s_dom,h_alg,psk)) = h_alg [private].
reduc forall c_dom,s_dom:domain, h_alg:hash_alg, psk:preSharedKey;
  get_ipsk(mk_idpsk(c_dom,s_dom,h_alg,psk)) = psk [private].

(* The extension itself *)
type preSharedKeyExt.
const empty_psk_ext: preSharedKeyExt [data].
fun trunc_client_psk_ext(identityPsk):preSharedKeyExt [data].
fun client_psk_ext(identityPsk,bitstring):preSharedKeyExt [data].
fun server_psk_ext(nat):preSharedKeyExt [data]. (* We only model a single psk offered
  by the client currently so the server is always suppose to send 1. *)

(* The global table storing the pre shared key on the client side. *)
table pre_shared_keys(
  domain (* Client domain *),
  domain (* Server domain *),
  hash_alg, (* The hash algorithm used in the handshake *)
  identityPsk, (* The identify of the pre shared key generated *)
  preSharedKey, (* The pre shared key itself *)
  idProc, (* The process identifier that generated the pre shared key *)
  bool (* Value determining if the key was considered uncompromised (true) or
    not (false).*)
).

(********************************************************)
(* Long term keys and certificates                      *)
(********************************************************)

type certificate.
fun valid_cert(domain,pubkey):certificate [private].
fun cert(domain,pubkey):certificate.

fun get_pkey(certificate):pubkey
reduc
  forall d:domain, pkey:pubkey; get_pkey(valid_cert(d,pkey)) = pkey
  otherwise forall d:domain, pkey:pubkey; get_pkey(cert(d,pkey)) = pkey.

fun get_domain(certificate):domain
reduc
  forall d:domain, pkey:pubkey; get_domain(valid_cert(d,pkey)) = d
  otherwise forall d:domain, pkey:pubkey; get_domain(cert(d,pkey)) = d.

fun verify_cert(certificate):bool
reduc forall d:domain, p:pubkey;
  verify_cert(valid_cert(d,p)) = true .

table long_term_keys(domain,privkey,pubkey,certificate,idProc).

(***************************************
  Echo Configuration
****************************************)

(* Data structure of ECHConfig. We flatten the data structure with respect to the
  RFC. In particular, in the RFC, HpkeSymmetricCipherSuite is composed of an id
  for aead and kdf. Our kdf being based on the hash function, we parametrise it
  by hash_alg.
  Similarly, the HpkeKemId will be determined by a DH group.

  A server should be parametrised by its ech_config and the private key associated
  to public_key.
*)


type configId.

type echConfig.
fun ech_config(
  configId (* config id *),
  group (* kem_id directly represented as a group *),
  element (* public_key *),
  domain (* public_name *),
  hash_alg (* kdf_id *),
  aead_alg (* aead_id *)
):echConfig [data].

letfun get_public_key(conf:echConfig) =
  let ech_config(id,g,public_key,dom,hl,al) = conf in
  public_key.

letfun get_cipher_suite(conf:echConfig) =
  let ech_config(id,g,public_key,dom,hl,al) = conf in
  (hl,al).

letfun get_config_id(conf:echConfig) =
  let ech_config(id,g,public_key,dom,hl,al) = conf in
  id.

letfun get_public_name(conf:echConfig) =
  let ech_config(id,g,public_key,dom,hl,al) = conf in
  dom.

const ech_accept_confirmation,tls_ech_str:label.

table ech_configurations(
  echConfig, (* Ech configuration *)
  bitstring). (* The secret key skR *)

(***************************************
  Encrypted Client Hello Extension
****************************************)

type echExt.

fun echExt2b(echExt):bitstring [typeConverter].

(* Represents the absence of extension *)
const empty_ech_ext: echExt.

(* This extension should only occur in the ClientHelloInner. *)
const ech_is_inner: echExt.

(* This extension should only occur in the ClientHelloOuter. *)
(* This includes the following element
    - cipher_suite of type [cipherSuite];
    - config_id of type [uint8] in RFC ([configId] in this model). Should be the same
      as in the ECH config.
    - enc of type [opaque] in RFC ([element] in this model). It's the The HPKE encapsulated key
    - payload of type [opaque] in RFC ([bitstring] in this model).
*)
fun client_ECH(hash_alg,aead_alg,configId,element,bitstring): echExt [data].

(* The Encrypted Client Hello extension for the server. It should normally include
  a list of accepted ECHConfig but we only model one here.*)
fun server_ECH(echConfig): echExt [data].

(***************************************
  TLS messages
****************************************)

type TLS_version.
const TLS13: TLS_version.

const rand_HelloRetryRequest:bytes32.

(* The SNI extension *)
type sniExt.
fun SNI(domain): sniExt [data].
const empty_sni_ext: sniExt [data].

(* The parameters of the Client and Server Hello. The last argument can be used to
  add any other informations *)
type params.
fun nego(TLS_version,hash_alg,aead_alg,keyShareExt,sniExt,echExt,preSharedKeyExt,extraExt):params [data].

type msg.
fun m2b(msg):bitstring [typeConverter].
fun CH(bytes32,params):msg [data].
fun SH(bytes32,params):msg [data].

(* Encrypted Extensions. Can contain zero or any additional extensions. *)
fun EE(bitstring): msg [data].

(* Certificate Request message. We only model the certificate_request_context
  but not the extesions, even though in the RFC, it is indicated that
    "the "signature_algorithms" extension MUST be specified"
  Since we only model one signature algorithm, we omit it *)
fun CRTR(bitstring): msg [data].

(* The first argument of certificate corresponds to certificate_request_context *)
fun CRT(bitstring,certificate):msg [data].

(* Corresponds to the Certificate Verify message. We only consider the signature
  since we model only one signature algorithm. *)
fun CV(bitstring):msg [data].

(* The Finished message *)
fun FIN(bitstring):msg [data].

type error_signal.
const
  illegal_parameter,unsupported_certificate,decode_error,
  unexpected_message, handshake_failure,
  abort_error,bad_record_mac,
  unrecognized_name, unsupported_extension
  :error_signal.

(***************************************
  Session states
****************************************)

table clientSession(
  aead_alg,bytes32,bytes32,
  preSharedKey,pubkey,
  aead_key,aead_key,bitstring,bitstring).

table serverSession(
  aead_alg,bytes32,bytes32,
  preSharedKey,pubkey,
  aead_key,aead_key,bitstring,bitstring).
