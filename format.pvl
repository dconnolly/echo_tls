channel io.

type domain.
const NoDomain:domain [data].
fun d2b(domain):bitstring [typeConverter].

(********************************************************)
(* Extra extension                                      *)
(********************************************************)

type extraExt.
const empty_extra_ext:extraExt [data].

(********************************************************)
(* Key Share Extension                                  *)
(********************************************************)

type kex_alg.
fun DHE_group(group): kex_alg [data].
fun DHE_kex(group,element) : kex_alg [data].

type keyShareExt.
fun client_kex_ext(kex_alg): keyShareExt [data].
fun server_kex_ext(kex_alg): keyShareExt [data].
fun hrr_kex_ext(group): keyShareExt [data].

(********************************************************)
(* Pre Shared Keys Extension                            *)
(********************************************************)

type internal_preSharedKey.
fun ipsk2b(internal_preSharedKey):bitstring [typeConverter].
type preSharedKey.
const NoPSK: preSharedKey.
fun PSK(internal_preSharedKey): preSharedKey [data].


fun psk_h(seed):internal_preSharedKey [private].
fun psk_d(seed):internal_preSharedKey [private].
letfun mk_psk_h() = new s:seed; psk_h(s).
letfun mk_psk_d() = new s:seed; psk_d(s).

type identityPsk.

fun psk2b(preSharedKey): bitstring
reduc forall b:internal_preSharedKey; psk2b(PSK(b)) = ipsk2b(b)
otherwise psk2b(NoPSK) = zero.

type preSharedKeyExt.
const empty_psk_ext: preSharedKeyExt [data].
fun trunc_client_psk_ext(identityPsk):preSharedKeyExt [data].
fun client_psk_ext(identityPsk,bitstring):preSharedKeyExt [data].
fun server_psk_ext(nat):preSharedKeyExt [data]. (* We only model a single psk offered
  by the client currently so the server is always suppose to send 1. *)

table pre_shared_keys(
  domain (* Client domain *),
  domain (* Server domain *),
  hash_alg,identityPsk,internal_preSharedKey).

letfun dummy_preSharedKeyExt () =
  new id:identityPsk;
  new n:bitstring;
  client_psk_ext(id,n)
.

(********************************************************)
(* Long term keys and certificates                      *)
(********************************************************)

type certificate.
fun valid_cert(domain,pubkey):certificate [private].
fun cert(domain,pubkey):certificate.

fun get_pkey(certificate):pubkey
reduc
  forall d:domain, pkey:pubkey; get_pkey(valid_cert(d,pkey)) = pkey
  otherwise forall d:domain, pkey:pubkey; get_pkey(cert(d,pkey)) = pkey.

fun get_domain(certificate):domain
reduc
  forall d:domain, pkey:pubkey; get_domain(valid_cert(d,pkey)) = d
  otherwise forall d:domain, pkey:pubkey; get_domain(cert(d,pkey)) = d.

fun verify_cert(certificate):bool
reduc forall d:domain, p:pubkey;
  verify_cert(valid_cert(d,p)) = true .

table long_term_keys(domain,privkey,pubkey,certificate).

(***************************************
  Echo Configuration
****************************************)

(* Data structure of ECHConfig. We flatten the data structure with respect to the
  RFC. In particular, in the RFC, HpkeSymmetricCipherSuite is composed of an id
  for aead and kdf. Our kdf being based on the hash function, we parametrise it
  by hash_alg.
  Similarly, the HpkeKemId will be determined by a DH group.

  A server should be parametrised by its ech_config and the private key associated
  to public_key.
*)


type configId.

type echConfig.
fun ech_config(
  configId (* config id *),
  group (* kem_id directly represented as a group *),
  element (* public_key *),
  domain (* public_name *),
  hash_alg (* kdf_id *),
  aead_alg (* aead_id *)
):echConfig [data].

letfun get_public_key(conf:echConfig) =
  let ech_config(id,g,public_key,dom,hl,al) = conf in
  public_key.

letfun get_cipher_suite(conf:echConfig) =
  let ech_config(id,g,public_key,dom,hl,al) = conf in
  (hl,al).

letfun get_config_id(conf:echConfig) =
  let ech_config(id,g,public_key,dom,hl,al) = conf in
  id.

letfun get_public_name(conf:echConfig) =
  let ech_config(id,g,public_key,dom,hl,al) = conf in
  dom.

const ech_accept_confirmation,tls_ech_str:label.

table ech_configurations(
  echConfig, (* Ech configuration *)
  bitstring). (* The secret key skR *)

(***************************************
  Encrypted Client Hello Extension
****************************************)

type echExt.

fun echExt2b(echExt):bitstring [typeConverter].

(* Represents the absence of extension *)
const empty_ech_ext: echExt.

(* This extension should only occur in the ClientHelloInner. *)
const ech_is_inner: echExt.

(* This extension should only occur in the ClientHelloOuter. *)
(* This includes the following element
    - cipher_suite of type [cipherSuite];
    - config_id of type [uint8] in RFC ([configId] in this model). Should be the same
      as in the ECH config.
    - enc of type [opaque] in RFC ([element] in this model). It's the The HPKE encapsulated key
    - payload of type [opaque] in RFC ([bitstring] in this model).
*)
fun client_ECH(hash_alg,aead_alg,configId,element,bitstring): echExt [data].

(* The Encrypted Client Hello extension for the server. It should normally include
  a list of accepted ECHConfig but we only model one here.*)
fun server_ECH(echConfig): echExt [data].

(***************************************
  TLS messages
****************************************)

type TLS_version.
const TLS13: TLS_version.

const rand_HelloRetryRequest:bytes32.

(* The SNI extension *)
type sniExt.
fun SNI(domain): sniExt [data].
const empty_sni_ext: sniExt [data].

(* The parameters of the Client and Server Hello. The last argument can be used to
  add any other informations *)
type params.
fun nego(TLS_version,hash_alg,aead_alg,keyShareExt,sniExt,echExt,preSharedKeyExt,extraExt):params [data].

type msg.
fun m2b(msg):bitstring [typeConverter].
fun CH(bytes32,params):msg [data].
fun SH(bytes32,params):msg [data].

(* Encrypted Extensions. Can contain zero or any additional extensions. *)
fun EE(bitstring): msg [data].

(* Certificate Request message. We only model the certificate_request_context
  but not the extesions, even though in the RFC, it is indicated that
    "the "signature_algorithms" extension MUST be specified"
  Since we only model one signature algorithm, we omit it *)
fun CRTR(bitstring): msg [data].

(* The first argument of certificate corresponds to certificate_request_context *)
fun CRT(bitstring,certificate):msg [data].

(* Corresponds to the Certificate Verify message. We only consider the signature
  since we model only one signature algorithm. *)
fun CV(bitstring):msg [data].

(* The Finished message *)
fun FIN(bitstring):msg [data].

type error_signal.
const
  illegal_parameter,unsupported_certificate,decode_error,
  unexpected_message, handshake_failure,
  abort_error,bad_record_mac,
  unrecognized_name, unsupported_extension
  :error_signal.

(***************************************
  Session states
****************************************)

table clientSession(bytes32,bytes32,
  preSharedKey,pubkey,pubkey,
  aead_key,aead_key,bitstring,bitstring).

table serverSession(bytes32,bytes32,
  preSharedKey,pubkey,pubkey,
  aead_key,aead_key,bitstring,bitstring).
