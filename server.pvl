(********************
  Server processes
*********************)

letfun generate_early_secret_psk_extension(
  use_psk:bool,
  c_dom,s_dom:domain,
  client_hello:msg,
  cur_log:bitstring
  ) =
  (* The cipher suite should have already been verified *)
  let CH(cr,nego(=TLS13,h_alg,a_alg,kex_ext,sni_ext,ech_ext,psk_ext,extra_ext)) = client_hello in

  let (client_psk_ext(id,binders),=true) = (psk_ext,use_psk) in (
    get pre_shared_keys(=c_dom,=s_dom,=h_alg,=id,internal_psk) in
    let psk = PSK(internal_psk) in
    let (early_secret:bitstring,kb:mac_key) = kdf_es(h_alg,psk) in
    let offer = nego(TLS13,h_alg,a_alg,kex_ext,sni_ext,ech_ext,trunc_client_psk_ext(id),extra_ext) in
    let cur_log' = (cur_log,CH(cr,offer)) in
    if binders = hmac(h_alg,kb,cur_log') then
    (early_secret, server_psk_ext(1), psk)
  )
  else
    let (es:bitstring,kb:mac_key) = kdf_es(h_alg,NoPSK) in
    (es, empty_psk_ext, NoPSK)
.

(* Receive the client finished message *)

let receive_client_finished_message(id_server:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  psk:preSharedKey, s_pkey,c_pkey:pubkey,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =


  in(io,enc_fin:bitstring);
  let m2b(fin_msg) = aead_dec(a_alg,chk,zero,zero,enc_fin) in
  let FIN(hash_msg) = fin_msg in

  if hash_msg = hmac(h_alg,cfin,cur_log) then
  let (cak:aead_key,sak:aead_key,ems:bitstring) = kdf_k(h_alg,master_secret,cur_log) in
  let cur_log_CFIN = (cur_log,fin_msg) in
  let rms = kdf_psk(h_alg,master_secret,cur_log_CFIN) in

  event SanityServerCFIN(id_server,
    cr,sr,psk,
    master_secret,chk,shk,cfin,sfin,
    s_pkey,c_pkey,
    cak,sak,ems,rms,
    cur_log_CFIN);

  insert serverSession(cr,sr,psk,s_pkey,c_pkey,cak,sak,ems,rms)
.

(* Sends the server finish message *)

let send_server_finished_message(
  id_server:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom,s_dom:domain, psk:preSharedKey, cert_req:bool, s_pkey:pubkey,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring)
  =

  let hash_msg = hmac(h_alg,sfin,cur_log) in
  let finished_msg = FIN(hash_msg) in
  let enc_finished = aead_enc(a_alg,shk,zero,zero,m2b(finished_msg)) in
  out(io,enc_finished);
  let cur_log_FIN = (cur_log,finished_msg) in

  event SanityServerFIN(id_server,
    cr,sr,psk,
    master_secret,chk,shk,cfin,sfin,
    s_pkey,
    cur_log_FIN);

  (* Receiving messages from the client depending on psk and cert_req *)
  if psk = NoPSK && cert_req
  then (
      (* A certificate request from the client is requested *)
      in(io,enc_cert_msg:bitstring);
      let m2b(cert_msg) = aead_dec(a_alg,chk,zero,zero,enc_cert_msg) in
      let CRT(=zero,crt) = cert_msg in

      let c_pkey = get_pkey(crt) in
      let cur_log_CRT = (cur_log_FIN,cert_msg) in

      event SanityServerCCRT(id_server,
        cr,sr,psk,
        master_secret,chk,shk,cfin,sfin,
        s_pkey,c_pkey,
        cur_log_CRT);

      in(io,enc_cert_verif_msg:bitstring);
      let m2b(cert_verify_msg) = aead_dec(a_alg,chk,zero,zero,enc_cert_verif_msg) in
      let CV(signed_log) = cert_verify_msg in

      if verify(c_pkey,hash(h_alg,cur_log_CRT),signed_log) && get_domain(crt) = c_dom && verify_cert(crt) then
      let cur_log_CV = (cur_log_CRT,cert_verify_msg) in

      event SanityServerCCV(id_server,
        cr,sr,psk,
        master_secret,chk,shk,cfin,sfin,
        s_pkey,c_pkey,
        cur_log_CV);

      receive_client_finished_message(id_server,
        cr,sr,h_alg,a_alg,
        psk,s_pkey,c_pkey,
        master_secret,chk,shk,cfin,sfin,
        cur_log_CV)
  )
  else
    (* A psk is used so no certificate or no psk is used but the server did not ask for a
    certificate request from the client *)
    receive_client_finished_message(id_server,
      cr,sr,h_alg,a_alg,
      psk,s_pkey,NoPubKey,
      master_secret,chk,shk,cfin,sfin,
      cur_log_FIN)
.

(* Send server certificate message *)

let send_server_certificate_message(
  id_server:idProc,
  cr,sr:bytes32, h_alg:hash_alg,a_alg:aead_alg,
  c_dom,s_dom:domain, psk:preSharedKey, cert_req:bool,
  master_secret:bitstring, chk,shk:aead_key, cfin,sfin:mac_key,
  cur_log:bitstring
  )
  =

  get long_term_keys(=s_dom,sk,s_pkey,crt) in

  (* The Certificate message *)
  let certificate_msg = CRT(zero,crt) in
  let encrypted_certificate_msg = aead_enc(a_alg,shk,zero,zero,m2b(certificate_msg)) in
  out(io,encrypted_certificate_msg);
  let cur_log_CRT = (cur_log,certificate_msg) in

  event SanityServerCRT(id_server,
    cr,sr,psk,
    master_secret,chk,shk,cfin,sfin,
    s_pkey,
    cur_log_CRT);

  (* The CertificateVerify message *)
  let signed_log = sign(sk,hash(h_alg,cur_log_CRT)) in
  let certificate_verify_msg = CV(signed_log) in
  let encrypted_certificate_verify_msg = aead_enc(a_alg,shk,zero,zero,m2b(certificate_verify_msg)) in
  out(io,encrypted_certificate_verify_msg);
  let cur_log_CV = (cur_log_CRT,certificate_verify_msg) in
  event SanityServerCV(id_server,
    cr,sr,psk,
    master_secret,chk,shk,cfin,sfin,
    s_pkey,
    cur_log_CV);

  send_server_finished_message(id_server,
    cr,sr,h_alg,a_alg,
    c_dom,s_dom,psk,cert_req, s_pkey,
    master_secret,chk,shk,cfin,sfin,
    cur_log_CV
  )
.

(* Following the TLS RFC and ECHO RFC, we consider server process that can have
  the following parameters:
    - [use_psk] indicate if the client uses Pre Shared Key
*)

let process_client_hello_noHRR(
  id_server:idProc,
  use_psk:bool,is_backend:bool,cert_req:bool,c_dom,s_dom:domain,
  g:group,h_alg:hash_alg,a_alg:aead_alg,
  s_extra:extraExt, encrypted_ext:bitstring,
  client_hello:msg, cur_log:bitstring (* Should not contain the curent client hello *)
  ) =

  let CH(cr,offer) = client_hello in
  (* Verify the cipher suite and group *)
  let nego(=TLS13,=h_alg,=a_alg,client_kex_ext(DHE_kex(=g,gx)),sni_ext,ech_ext,psk_ext,extra_ext) = offer in (
    if not(is_backend) || (ech_ext = ech_is_inner)
    then (
      if sni_ext = SNI(s_dom)
      then (
        (* Retrieve the early secret from the psk *)
        let (early_secret:bitstring,s_psk_ext:preSharedKeyExt,psk:preSharedKey) = generate_early_secret_psk_extension(use_psk,c_dom,s_dom,client_hello,cur_log) in

        let cur_log_CH = (cur_log,client_hello) in
        event SanityServerCH(id_server,is_backend,cr,c_dom,s_dom,psk,cur_log_CH);

        (* Generate key share and handshake secret *)
        let (gxy:element,gy:element) = dh_encap(g,gx,m2b(client_hello)) in
        let handshake_secret = kdf_hs(h_alg,early_secret,gxy) in

        let s_offer = nego(TLS13,h_alg,a_alg,server_kex_ext(DHE_kex(g,gy)),empty_sni_ext,empty_ech_ext,s_psk_ext,s_extra) in

        let sr =
          if is_backend
          then (
            (* Generate the accept confirmation when the it's a backend server. *)
            new sr24:bytes24;
            let SH_ECHConf = SH(B32(sr24,zero8),s_offer) in
            let cur_log_SH_ech = (cur_log_CH,SH_ECHConf) in
            let accept_confirmation = derive_secret(h_alg,handshake_secret,ech_accept_confirmation,cur_log_SH_ech) in
            let sr8 = crop_into_bytes8(accept_confirmation) in
            B32(sr24,sr8)
          )
          else gen_B32_random ()
        in

        let server_hello = SH(sr,s_offer) in
        out(io,server_hello);
        let cur_log_SH = (cur_log_CH,server_hello) in
        event SanityServerSH(id_server,cr,sr,c_dom,s_dom,handshake_secret,psk,cur_log_SH);

        (* Generate the master keys *)
        let (master_secret:bitstring,chk:aead_key,shk:aead_key,cfin:mac_key,sfin:mac_key) =
            kdf_ms(h_alg,handshake_secret,cur_log_SH) in

        (* Sending the encrypted extension *)
        let ee_msg = EE(encrypted_ext) in
        let enc_ee = aead_enc(a_alg,shk,zero,zero,m2b(ee_msg)) in
        out(io,enc_ee);
        let cur_log_EE = (cur_log_SH,ee_msg) in

        event SanityServerEE(id_server,
          cr,sr,psk,
          master_secret,chk,shk,cfin,sfin,
          cur_log_EE);

        (* Sends either the finish message or the certificate messages *)
        if psk = NoPSK
        then
          if cert_req
          then (
            (* The server requests a client certificate *)
            let crtr_msg = CRTR(zero) in
            let enc_crt = aead_enc(a_alg,shk,zero,zero,m2b(crtr_msg)) in
            out(io,enc_crt);
            let cur_log_CRTR = (cur_log_EE,crtr_msg) in
            event SanityServerCRTR(id_server,
              cr,sr,psk,
              master_secret,chk,shk,cfin,sfin,
              cur_log_CRTR);

            (* Sends the certificate *)
            send_server_certificate_message(id_server,
              cr,sr,h_alg,a_alg,
              c_dom,s_dom,psk,cert_req,
              master_secret,chk,shk,cfin,sfin,
              cur_log_CRTR)
          )
          else
            send_server_certificate_message(id_server,
              cr,sr,h_alg,a_alg,
              c_dom,s_dom,psk,cert_req,
              master_secret,chk,shk,cfin,sfin,
              cur_log_EE)
        else
          send_server_finished_message(id_server,
            cr,sr,h_alg,a_alg,
            c_dom,s_dom,psk,false,NoPubKey,
            master_secret,chk,shk,cfin,sfin,
            cur_log_EE)
      )
      else out(io,illegal_parameter)
    )
    else out(io,illegal_parameter)
  )
  else out(io,handshake_failure)
.

(* Generate of retry config for ECH *)

letfun create_retry_config(c_dom:domain,config:echConfig) =
  let ech_config(config_id,g,pkR,s_dom,h_alg,a_alg) = config in
  let (skR':bitstring,pkR':element) = dh_keygen(g) in
  new config_id':configId;
  ech_config(config_id',g,pkR',s_dom,h_alg,a_alg)
.

(* When the server acts as a client facing server *)

let process_client_hello_ClientFacingServer(
  id_server:idProc,
  use_psk,cert_req:bool,c_dom,o_dom:domain,
  g:group,h_alg:hash_alg,a_alg:aead_alg,
  s_extra:extraExt, o_client_hello:msg)
  =

  (* Verify that the ECH_config corresponds to the client hello message and that
    the decryption works.
    If the verification does not match then the server should continue the
    connection with the ClientHelloOuter. In RFC it is added that:
      This connection proceeds as usual, except the server MUST include the
      "encrypted_client_hello" extension in its EncryptedExtensions with
      the "retry_configs" field set to one or more ECHConfig structures
      with up-to-date keys.
  *)

  let CH(r,offer) = o_client_hello in
  let nego(=TLS13,=h_alg,=a_alg,kex_ext,sni_ext,ech_ext,=empty_psk_ext,extra_ext) = offer in
  let client_ECH(ech_h_alg,ech_a_alg,config_id,enc,payload) = ech_ext in

  let (s_dom:domain,client_hello:msg,encrypted_ext:bitstring,is_backend:bool) =
    get ech_configurations(ech_config(=config_id,ech_g,pkR,=o_dom,=ech_h_alg,=ech_a_alg),skR) in (
      let ech_conf = ech_config(config_id,ech_g,pkR,o_dom,ech_h_alg,ech_a_alg) in

      let client_hello_AAD = generate_client_hello_outer_AAD(o_client_hello) in
      let context = hpke_setup_base_R(ech_h_alg,ech_g,enc,skR,(tls_ech_str,ech_conf)) in

      (* When the verification succeed, the server must forward the message to
         the backend server.
         However, to be able to prove equivalence properties, we directly inline the
         actions of the back-end server without going through a private channel.

         The use of private channel would work for reachability properties but
         for equivalence, we would directly observe the difference between a sucessful
         and a rejected connexion.
      *)

      let m2b(i_client_hello) = hpke_open(ech_a_alg,context,aad2b(client_hello_AAD),payload) in (
        let CH(cr',nego(=TLS13,h_alg',a_alg',kex_ext',SNI(i_dom),ech_ext',empty_psk_ext',extra_ext')) = i_client_hello in
          (i_dom,i_client_hello,zero,true)
        else
          let retry_config = create_retry_config(c_dom,ech_conf) in
          (o_dom,o_client_hello,echExt2b(server_ECH(retry_config)),false)
      )
      else
        let retry_config = create_retry_config(c_dom,ech_conf) in
        (o_dom,o_client_hello,echExt2b(server_ECH(retry_config)),false)
    )
    else
      get ech_configurations(ech_config(config_id',ech_g',pkR',=o_dom,ech_h_alg',ech_a_alg'),skR') in
      let retry_config = create_retry_config(c_dom,ech_config(config_id',ech_g',pkR',o_dom,ech_h_alg',ech_a_alg')) in
      (o_dom,o_client_hello,echExt2b(server_ECH(retry_config)),false)
  in

  process_client_hello_noHRR(id_server,
    use_psk,is_backend,cert_req,c_dom,s_dom,
    g,h_alg,a_alg,
    s_extra, encrypted_ext,
    client_hello, zero
  )
.

(* The main server *)

let server(use_ech,use_psk,cert_req:bool,c_dom,s_dom:domain,g:group,h_alg:hash_alg,a_alg:aead_alg,s_extra:extraExt) =
  (****************************************************)
  (* Only for sanity checks *)
  new id_server:idProc;
  event SanityServer(id_server,use_ech,use_psk,cert_req);
  (****************************************************)

  (****************************************************)
  (* Forbiden combination of options                  *)
  if not (use_psk && cert_req) then
  (****************************************************)

  in(io,x_client_hello:msg);
  let CH(cr,offer) = x_client_hello in (
    let nego(=TLS13,c_h_alg,c_a_alg,kex_ext,sni_ext,ech_ext,psk_ext,extra_ext) = offer in

    (* Verify the cipher suite *)
    if c_h_alg = h_alg && c_a_alg = a_alg
    then (
      (* Verify the group *)
      let client_kex_ext(DHE_group(=g)) = kex_ext in (
        if sni_ext = SNI(s_dom)
        then (
          if use_ech
          then
            (* Received a correct group but no key share : Send a HelloRetryRequest
              Not implemented yet*)
            out(io,abort_error)
          else (
            (* Received a correct group but no key share : Send a HelloRetryRequest *)
            let hrr_mode = nego(TLS13,h_alg,a_alg,hrr_kex_ext(g),empty_sni_ext,empty_ech_ext,empty_psk_ext,empty_extra_ext) in
            let hello_retry_request = SH(rand_HelloRetryRequest,hrr_mode) in
            out(io,hello_retry_request);
            let cur_log_HRR = ((zero,x_client_hello),hello_retry_request) in
            event SanityServerHRR(id_server,cr,c_dom,s_dom,cur_log_HRR);

            (* Received the new client hello *)
            in(io,client_hello':msg);
            let CH(cr',offer') = client_hello' in
              process_client_hello_noHRR(id_server,
                use_psk,false,cert_req,c_dom,s_dom,
                g,h_alg,a_alg,
                s_extra,zero,
                client_hello',cur_log_HRR
              )
            else out(io,unexpected_message)
          )
        )
        else out(io,illegal_parameter)
      )
      else let client_kex_ext(DHE_kex(=g,gx)) = kex_ext in (
        (* Received a correct group and a key share *)
        let (client_ECH(ech_h_alg,ech_aead_alg,config_id,enc,payload),=true) = (ech_ext,use_ech) in
          process_client_hello_ClientFacingServer(id_server,
            use_psk,cert_req,c_dom,s_dom,
            g,h_alg,a_alg,
            s_extra,x_client_hello
          )
        else
          if (ech_ext = empty_ech_ext) || (ech_ext = ech_is_inner) || not(use_ech)
          then (
            let is_backend = (ech_ext = ech_is_inner) && use_ech in
            process_client_hello_noHRR(id_server,
              use_psk,is_backend,cert_req,c_dom,s_dom,
              g,h_alg,a_alg,
              s_extra,zero,
              x_client_hello,zero
            )
          )
          else out(io,illegal_parameter)
      )
      else
        (* Received an incorrect group or invalid kex extension *)
        out(io,handshake_failure)
    )
    else out(io,handshake_failure)
  )
  else out(io,unexpected_message)
.
